# Vento - Capa de Persistencia (DatabaseManager)

Vamos a crear una implementaci√≥n robusta del DatabaseManager siguiendo SOLID y las mejores pr√°cticas de C++20.

## üìÅ Estructura de Archivos a Crear/Modificar

```
src/core/
‚îú‚îÄ‚îÄ CMakeLists.txt              # Actualizado
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseManager.hpp     # Header principal
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseManager.cpp     # Implementaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseSchema.hpp      # Definici√≥n del esquema (separaci√≥n de responsabilidades)
‚îÇ   ‚îî‚îÄ‚îÄ QueryBuilder.hpp        # Helper para queries (opcional pero √∫til)
‚îú‚îÄ‚îÄ logger/
‚îÇ   ‚îú‚îÄ‚îÄ Logger.hpp              # Actualizado
‚îÇ   ‚îî‚îÄ‚îÄ Logger.cpp              # Actualizado
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ EventBus.hpp
    ‚îî‚îÄ‚îÄ Types.hpp               # Tipos comunes del proyecto
```

---

## üìÑ src/core/database/DatabaseSchema.hpp

```cpp
//==============================================================================
// DatabaseSchema.hpp
// Vento - Definici√≥n del esquema de base de datos
// 
// Principio: Single Responsibility
// Esta clase SOLO define el esquema, no ejecuta nada.
//==============================================================================
#pragma once

#include <QString>
#include <QStringList>
#include <array>

namespace Vento::Database {

//==============================================================================
// Versi√≥n del esquema (para futuras migraciones)
//==============================================================================
constexpr int SCHEMA_VERSION = 1;

//==============================================================================
// Nombres de tablas (constantes para evitar errores de tipeo)
//==============================================================================
namespace Tables {
    constexpr auto SETTINGS = "settings";
    constexpr auto PRODUCTS = "products";
    constexpr auto SALES = "sales";
    constexpr auto SALE_ITEMS = "sale_items";  // Para ventas con m√∫ltiples productos
    constexpr auto SCHEMA_INFO = "schema_info"; // Metadatos del esquema
}

//==============================================================================
// SQL de creaci√≥n de tablas
//==============================================================================
namespace Schema {

// Tabla de metadatos del esquema (para control de versiones/migraciones)
constexpr auto CREATE_SCHEMA_INFO = R"SQL(
    CREATE TABLE IF NOT EXISTS schema_info (
        id INTEGER PRIMARY KEY CHECK (id = 1),
        version INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime'))
    )
)SQL";

// Tabla de configuraciones (clave-valor)
// Aqu√≠ se guarda el precio del d√≥lar y otras configuraciones
constexpr auto CREATE_SETTINGS = R"SQL(
    CREATE TABLE IF NOT EXISTS settings (
        key TEXT PRIMARY KEY NOT NULL,
        value TEXT NOT NULL,
        description TEXT,
        updated_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime'))
    )
)SQL";

// Tabla de productos
constexpr auto CREATE_PRODUCTS = R"SQL(
    CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        
        -- Informaci√≥n b√°sica
        name TEXT NOT NULL,
        description TEXT,
        sku TEXT UNIQUE,
        barcode TEXT UNIQUE,
        category TEXT,
        
        -- Precios y costos
        cost_usd REAL NOT NULL DEFAULT 0.0,
        cost_local REAL NOT NULL DEFAULT 0.0,
        margin_percent REAL NOT NULL DEFAULT 0.0,
        sale_price REAL NOT NULL DEFAULT 0.0,
        
        -- Inventario
        stock_quantity INTEGER NOT NULL DEFAULT 0,
        min_stock_alert INTEGER DEFAULT 5,
        
        -- Control
        is_active INTEGER NOT NULL DEFAULT 1,
        created_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        
        -- Constraints
        CHECK (cost_usd >= 0),
        CHECK (cost_local >= 0),
        CHECK (margin_percent >= 0),
        CHECK (sale_price >= 0),
        CHECK (stock_quantity >= 0)
    )
)SQL";

// Tabla de ventas (encabezado)
constexpr auto CREATE_SALES = R"SQL(
    CREATE TABLE IF NOT EXISTS sales (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        
        -- Informaci√≥n de la venta
        sale_date TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        subtotal REAL NOT NULL DEFAULT 0.0,
        tax_percent REAL NOT NULL DEFAULT 0.0,
        tax_amount REAL NOT NULL DEFAULT 0.0,
        discount_amount REAL NOT NULL DEFAULT 0.0,
        total REAL NOT NULL DEFAULT 0.0,
        
        -- Tasa de cambio al momento de la venta (hist√≥rico)
        exchange_rate REAL NOT NULL DEFAULT 1.0,
        
        -- M√©todo de pago
        payment_method TEXT DEFAULT 'cash',
        
        -- Cliente (opcional para futuras expansiones)
        customer_name TEXT,
        customer_id TEXT,
        
        -- Estado
        status TEXT NOT NULL DEFAULT 'completed',
        notes TEXT,
        
        -- Control
        created_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        
        CHECK (subtotal >= 0),
        CHECK (total >= 0),
        CHECK (status IN ('pending', 'completed', 'cancelled', 'refunded'))
    )
)SQL";

// Tabla de items de venta (detalle)
constexpr auto CREATE_SALE_ITEMS = R"SQL(
    CREATE TABLE IF NOT EXISTS sale_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sale_id INTEGER NOT NULL,
        product_id INTEGER NOT NULL,
        
        -- Snapshot del producto al momento de la venta
        product_name TEXT NOT NULL,
        unit_price REAL NOT NULL,
        quantity INTEGER NOT NULL DEFAULT 1,
        subtotal REAL NOT NULL,
        
        -- Control
        created_at TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
        
        -- Foreign Keys
        FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE,
        FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
        
        CHECK (quantity > 0),
        CHECK (unit_price >= 0),
        CHECK (subtotal >= 0)
    )
)SQL";

// √çndices para optimizaci√≥n
constexpr auto CREATE_INDEXES = R"SQL(
    CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
    CREATE INDEX IF NOT EXISTS idx_products_sku ON products(sku);
    CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
    CREATE INDEX IF NOT EXISTS idx_products_active ON products(is_active);
    CREATE INDEX IF NOT EXISTS idx_sales_date ON sales(sale_date);
    CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);
    CREATE INDEX IF NOT EXISTS idx_sale_items_sale ON sale_items(sale_id);
    CREATE INDEX IF NOT EXISTS idx_sale_items_product ON sale_items(product_id);
)SQL";

// Datos iniciales
constexpr auto INSERT_DEFAULT_SETTINGS = R"SQL(
    INSERT OR IGNORE INTO settings (key, value, description) VALUES 
        ('exchange_rate_usd', '36.50', 'Tasa de cambio USD a moneda local'),
        ('currency_symbol_local', 'Bs.', 'S√≠mbolo de moneda local'),
        ('currency_symbol_usd', '$', 'S√≠mbolo de USD'),
        ('tax_percent', '16.0', 'Porcentaje de impuesto por defecto'),
        ('store_name', 'Mi Tienda', 'Nombre del negocio'),
        ('app_theme', 'light', 'Tema de la aplicaci√≥n (light/dark)')
)SQL";

constexpr auto INSERT_SCHEMA_VERSION = R"SQL(
    INSERT OR IGNORE INTO schema_info (id, version) VALUES (1, %1)
)SQL";

} // namespace Schema

//==============================================================================
// Lista ordenada de statements para inicializaci√≥n
//==============================================================================
inline QStringList getInitializationStatements() {
    return {
        Schema::CREATE_SCHEMA_INFO,
        Schema::CREATE_SETTINGS,
        Schema::CREATE_PRODUCTS,
        Schema::CREATE_SALES,
        Schema::CREATE_SALE_ITEMS
    };
}

inline QStringList getIndexStatements() {
    // Separar cada CREATE INDEX en su propia l√≠nea
    QString indexSql = Schema::CREATE_INDEXES;
    return indexSql.split(';', Qt::SkipEmptyParts);
}

inline QStringList getDefaultDataStatements() {
    return {
        Schema::INSERT_DEFAULT_SETTINGS,
        QString(Schema::INSERT_SCHEMA_VERSION).arg(SCHEMA_VERSION)
    };
}

} // namespace Vento::Database
```

---

## üìÑ src/core/database/DatabaseManager.hpp

```cpp
//==============================================================================
// DatabaseManager.hpp
// Vento - Gestor de conexi√≥n y operaciones de base de datos SQLite
//
// Principios SOLID aplicados:
// - Single Responsibility: Solo gestiona conexi√≥n e inicializaci√≥n
// - Open/Closed: Extensible v√≠a DatabaseSchema sin modificar esta clase
// - Dependency Inversion: Usa abstracciones (interfaces) donde es posible
//==============================================================================
#pragma once

#include <QObject>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QString>
#include <QVariant>
#include <QMutex>

#include <optional>
#include <functional>
#include <expected>  // C++23, o usar std::optional como fallback

namespace Vento {

//==============================================================================
// Resultado de operaci√≥n de base de datos
//==============================================================================
struct DatabaseResult {
    bool success = false;
    QString errorMessage;
    QVariant data;  // Datos opcionales del resultado
    
    // Operador de conversi√≥n impl√≠cita a bool
    explicit operator bool() const { return success; }
    
    // Factory methods
    static DatabaseResult ok(const QVariant& data = {}) {
        return {true, {}, data};
    }
    
    static DatabaseResult error(const QString& message) {
        return {false, message, {}};
    }
};

//==============================================================================
// Configuraci√≥n de la base de datos
//==============================================================================
struct DatabaseConfig {
    QString path;
    QString connectionName = "VentoConnection";
    bool enableForeignKeys = true;
    bool enableWAL = true;  // Write-Ahead Logging para mejor rendimiento
    int busyTimeout = 5000; // ms
};

//==============================================================================
// DatabaseManager - Singleton Thread-Safe
//==============================================================================
class DatabaseManager : public QObject {
    Q_OBJECT
    
    // Propiedades expuestas a QML
    Q_PROPERTY(bool isConnected READ isConnected NOTIFY connectionChanged)
    Q_PROPERTY(QString databasePath READ databasePath NOTIFY connectionChanged)
    Q_PROPERTY(int schemaVersion READ schemaVersion CONSTANT)
    
public:
    //--------------------------------------------------------------------------
    // Singleton Access
    //--------------------------------------------------------------------------
    static DatabaseManager& instance();
    
    // Prevent copying and moving
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;
    DatabaseManager(DatabaseManager&&) = delete;
    DatabaseManager& operator=(DatabaseManager&&) = delete;
    
    //--------------------------------------------------------------------------
    // Inicializaci√≥n y conexi√≥n
    //--------------------------------------------------------------------------
    
    /// Inicializa la base de datos con la configuraci√≥n dada
    /// @param config Configuraci√≥n de conexi√≥n
    /// @return Resultado de la operaci√≥n
    [[nodiscard]] DatabaseResult initialize(const DatabaseConfig& config);
    
    /// Sobrecarga simple con solo la ruta
    [[nodiscard]] DatabaseResult initialize(const QString& dbPath);
    
    /// Cierra la conexi√≥n a la base de datos
    void close();
    
    /// Verifica si est√° conectado
    [[nodiscard]] bool isConnected() const;
    
    /// Obtiene la ruta de la base de datos
    [[nodiscard]] QString databasePath() const;
    
    /// Obtiene la versi√≥n del esquema
    [[nodiscard]] int schemaVersion() const;
    
    //--------------------------------------------------------------------------
    // Operaciones de base de datos
    //--------------------------------------------------------------------------
    
    /// Ejecuta una query sin retorno de datos (INSERT, UPDATE, DELETE)
    /// @param sql Query SQL con placeholders (?)
    /// @param params Par√°metros para los placeholders
    /// @return Resultado con el lastInsertId si aplica
    [[nodiscard]] DatabaseResult execute(
        const QString& sql, 
        const QVariantList& params = {}
    );
    
    /// Ejecuta una query y retorna un solo valor
    /// @param sql Query SQL
    /// @param params Par√°metros
    /// @return Resultado con el valor
    [[nodiscard]] DatabaseResult executeScalar(
        const QString& sql, 
        const QVariantList& params = {}
    );
    
    /// Ejecuta una query y retorna todos los resultados
    /// @param sql Query SQL
    /// @param params Par√°metros
    /// @return Lista de mapas (columna -> valor)
    [[nodiscard]] QList<QVariantMap> executeQuery(
        const QString& sql, 
        const QVariantList& params = {}
    );
    
    /// Ejecuta m√∫ltiples statements en una transacci√≥n
    /// @param statements Lista de SQL statements
    /// @return Resultado de la operaci√≥n
    [[nodiscard]] DatabaseResult executeTransaction(
        const QStringList& statements
    );
    
    /// Ejecuta una funci√≥n dentro de una transacci√≥n
    /// @param func Funci√≥n que recibe la query y retorna √©xito/fallo
    /// @return Resultado de la operaci√≥n
    [[nodiscard]] DatabaseResult executeInTransaction(
        std::function<bool(QSqlQuery&)> func
    );
    
    //--------------------------------------------------------------------------
    // Utilidades
    //--------------------------------------------------------------------------
    
    /// Verifica si una tabla existe
    [[nodiscard]] bool tableExists(const QString& tableName);
    
    /// Obtiene el n√∫mero de filas en una tabla
    [[nodiscard]] int rowCount(const QString& tableName);
    
    /// Obtiene el √∫ltimo ID insertado
    [[nodiscard]] qint64 lastInsertId();
    
    /// Obtiene la base de datos (para operaciones avanzadas)
    [[nodiscard]] QSqlDatabase& database();
    
    /// Crea una query preparada
    [[nodiscard]] QSqlQuery createQuery();
    
    /// Ejecuta VACUUM para optimizar la base de datos
    [[nodiscard]] DatabaseResult vacuum();
    
    /// Obtiene estad√≠sticas de la base de datos
    [[nodiscard]] QVariantMap getStatistics();
    
signals:
    /// Emitido cuando cambia el estado de conexi√≥n
    void connectionChanged(bool connected);
    
    /// Emitido cuando hay un error
    void errorOccurred(const QString& error);
    
    /// Emitido cuando las tablas se inicializan
    void tablesInitialized();
    
    /// Emitido cuando se completa una migraci√≥n
    void migrationCompleted(int fromVersion, int toVersion);
    
private:
    //--------------------------------------------------------------------------
    // Constructor privado (Singleton)
    //--------------------------------------------------------------------------
    DatabaseManager();
    ~DatabaseManager() override;
    
    //--------------------------------------------------------------------------
    // M√©todos privados
    //--------------------------------------------------------------------------
    
    /// Inicializa las tablas del esquema
    [[nodiscard]] DatabaseResult initializeTables();
    
    /// Configura opciones de SQLite (PRAGMA)
    [[nodiscard]] DatabaseResult configureSQLite();
    
    /// Verifica y ejecuta migraciones si es necesario
    [[nodiscard]] DatabaseResult checkAndMigrate();
    
    /// Obtiene la versi√≥n actual del esquema en la BD
    [[nodiscard]] int getCurrentSchemaVersion();
    
    /// Log de error con detalles de QSqlError
    void logSqlError(const QString& context, const QSqlError& error);
    
    //--------------------------------------------------------------------------
    // Miembros privados
    //--------------------------------------------------------------------------
    QSqlDatabase m_database;
    DatabaseConfig m_config;
    bool m_connected = false;
    mutable QMutex m_mutex;  // Para thread-safety
};

} // namespace Vento
```

---

## üìÑ src/core/database/DatabaseManager.cpp

```cpp
//==============================================================================
// DatabaseManager.cpp
// Vento - Implementaci√≥n del gestor de base de datos
//==============================================================================

#include "DatabaseManager.hpp"
#include "DatabaseSchema.hpp"
#include "core/logger/Logger.hpp"

#include <QSqlRecord>
#include <QSqlDriver>
#include <QFileInfo>
#include <QDir>
#include <QDateTime>
#include <QThread>

namespace Vento {

//==============================================================================
// Singleton Instance
//==============================================================================
DatabaseManager& DatabaseManager::instance() {
    static DatabaseManager instance;
    return instance;
}

//==============================================================================
// Constructor / Destructor
//==============================================================================
DatabaseManager::DatabaseManager() : QObject(nullptr) {
    Logger::instance().debug("DatabaseManager creado");
}

DatabaseManager::~DatabaseManager() {
    close();
    Logger::instance().debug("DatabaseManager destruido");
}

//==============================================================================
// Inicializaci√≥n
//==============================================================================
DatabaseResult DatabaseManager::initialize(const QString& dbPath) {
    DatabaseConfig config;
    config.path = dbPath;
    return initialize(config);
}

DatabaseResult DatabaseManager::initialize(const DatabaseConfig& config) {
    QMutexLocker locker(&m_mutex);
    
    // Si ya est√° conectado, cerrar primero
    if (m_connected) {
        Logger::instance().warning("Base de datos ya conectada. Reconectando...");
        close();
    }
    
    m_config = config;
    
    Logger::instance().info(QString("Inicializando base de datos: %1").arg(config.path));
    
    //--------------------------------------------------------------------------
    // Verificar/crear directorio
    //--------------------------------------------------------------------------
    QFileInfo fileInfo(config.path);
    QDir dir = fileInfo.absoluteDir();
    
    if (!dir.exists()) {
        if (!dir.mkpath(".")) {
            auto error = QString("No se pudo crear el directorio: %1").arg(dir.absolutePath());
            Logger::instance().error(error);
            return DatabaseResult::error(error);
        }
        Logger::instance().info(QString("Directorio creado: %1").arg(dir.absolutePath()));
    }
    
    //--------------------------------------------------------------------------
    // Crear conexi√≥n
    //--------------------------------------------------------------------------
    if (QSqlDatabase::contains(config.connectionName)) {
        m_database = QSqlDatabase::database(config.connectionName);
    } else {
        m_database = QSqlDatabase::addDatabase("QSQLITE", config.connectionName);
    }
    
    m_database.setDatabaseName(config.path);
    
    //--------------------------------------------------------------------------
    // Abrir conexi√≥n
    //--------------------------------------------------------------------------
    if (!m_database.open()) {
        logSqlError("Abrir base de datos", m_database.lastError());
        return DatabaseResult::error(
            QString("Error al abrir base de datos: %1").arg(m_database.lastError().text())
        );
    }
    
    m_connected = true;
    Logger::instance().info("‚úì Conexi√≥n a base de datos establecida");
    
    //--------------------------------------------------------------------------
    // Configurar SQLite
    //--------------------------------------------------------------------------
    auto configResult = configureSQLite();
    if (!configResult) {
        return configResult;
    }
    
    //--------------------------------------------------------------------------
    // Inicializar tablas
    //--------------------------------------------------------------------------
    auto tablesResult = initializeTables();
    if (!tablesResult) {
        return tablesResult;
    }
    
    //--------------------------------------------------------------------------
    // Verificar migraciones
    //--------------------------------------------------------------------------
    auto migrateResult = checkAndMigrate();
    if (!migrateResult) {
        return migrateResult;
    }
    
    emit connectionChanged(true);
    emit tablesInitialized();
    
    Logger::instance().info(QString("‚úì Base de datos inicializada correctamente (v%1)")
        .arg(Database::SCHEMA_VERSION));
    
    return DatabaseResult::ok();
}

//==============================================================================
// Configuraci√≥n de SQLite
//==============================================================================
DatabaseResult DatabaseManager::configureSQLite() {
    QSqlQuery query(m_database);
    
    // Lista de PRAGMAs para optimizaci√≥n
    QStringList pragmas;
    
    // Foreign Keys
    if (m_config.enableForeignKeys) {
        pragmas << "PRAGMA foreign_keys = ON";
    }
    
    // Write-Ahead Logging (mejor rendimiento en escrituras concurrentes)
    if (m_config.enableWAL) {
        pragmas << "PRAGMA journal_mode = WAL";
    }
    
    // Timeout para operaciones bloqueadas
    pragmas << QString("PRAGMA busy_timeout = %1").arg(m_config.busyTimeout);
    
    // Sincronizaci√≥n (NORMAL es un buen balance entre seguridad y velocidad)
    pragmas << "PRAGMA synchronous = NORMAL";
    
    // Cache size (en p√°ginas, negativo = KB)
    pragmas << "PRAGMA cache_size = -2000";  // 2MB de cache
    
    // Temp store en memoria
    pragmas << "PRAGMA temp_store = MEMORY";
    
    // Ejecutar PRAGMAs
    for (const QString& pragma : pragmas) {
        if (!query.exec(pragma)) {
            logSqlError(pragma, query.lastError());
            // No es cr√≠tico, continuamos
            Logger::instance().warning(QString("PRAGMA fall√≥: %1").arg(pragma));
        }
    }
    
    Logger::instance().debug("‚úì SQLite configurado con PRAGMAs de optimizaci√≥n");
    return DatabaseResult::ok();
}

//==============================================================================
// Inicializaci√≥n de tablas
//==============================================================================
DatabaseResult DatabaseManager::initializeTables() {
    Logger::instance().info("Inicializando tablas del esquema...");
    
    // Comenzar transacci√≥n
    if (!m_database.transaction()) {
        return DatabaseResult::error("No se pudo iniciar transacci√≥n");
    }
    
    QSqlQuery query(m_database);
    
    try {
        //----------------------------------------------------------------------
        // Crear tablas
        //----------------------------------------------------------------------
        for (const QString& sql : Database::getInitializationStatements()) {
            if (!query.exec(sql)) {
                logSqlError("Crear tabla", query.lastError());
                m_database.rollback();
                return DatabaseResult::error(
                    QString("Error creando tabla: %1").arg(query.lastError().text())
                );
            }
        }
        Logger::instance().debug("  ‚úì Tablas principales creadas");
        
        //----------------------------------------------------------------------
        // Crear √≠ndices
        //----------------------------------------------------------------------
        for (const QString& sql : Database::getIndexStatements()) {
            QString trimmedSql = sql.trimmed();
            if (trimmedSql.isEmpty()) continue;
            
            if (!query.exec(trimmedSql)) {
                logSqlError("Crear √≠ndice", query.lastError());
                // Los √≠ndices no son cr√≠ticos, continuamos
                Logger::instance().warning(QString("√çndice no creado: %1").arg(trimmedSql.left(50)));
            }
        }
        Logger::instance().debug("  ‚úì √çndices creados");
        
        //----------------------------------------------------------------------
        // Insertar datos por defecto
        //----------------------------------------------------------------------
        for (const QString& sql : Database::getDefaultDataStatements()) {
            if (!query.exec(sql)) {
                logSqlError("Insertar datos default", query.lastError());
                // No es cr√≠tico si ya existen (INSERT OR IGNORE)
            }
        }
        Logger::instance().debug("  ‚úì Datos por defecto insertados");
        
        //----------------------------------------------------------------------
        // Commit
        //----------------------------------------------------------------------
        if (!m_database.commit()) {
            m_database.rollback();
            return DatabaseResult::error("Error en commit de transacci√≥n");
        }
        
        Logger::instance().info("‚úì Todas las tablas inicializadas correctamente");
        return DatabaseResult::ok();
        
    } catch (const std::exception& e) {
        m_database.rollback();
        return DatabaseResult::error(QString("Excepci√≥n: %1").arg(e.what()));
    }
}

//==============================================================================
// Migraciones
//==============================================================================
int DatabaseManager::getCurrentSchemaVersion() {
    QSqlQuery query(m_database);
    query.prepare("SELECT version FROM schema_info WHERE id = 1");
    
    if (query.exec() && query.next()) {
        return query.value(0).toInt();
    }
    
    return 0;  // No existe, base de datos nueva
}

DatabaseResult DatabaseManager::checkAndMigrate() {
    int currentVersion = getCurrentSchemaVersion();
    int targetVersion = Database::SCHEMA_VERSION;
    
    if (currentVersion == targetVersion) {
        Logger::instance().debug(QString("Esquema actualizado (v%1)").arg(currentVersion));
        return DatabaseResult::ok();
    }
    
    if (currentVersion > targetVersion) {
        Logger::instance().warning(
            QString("Versi√≥n de BD (%1) mayor que la aplicaci√≥n (%2)")
            .arg(currentVersion).arg(targetVersion)
        );
        return DatabaseResult::ok();  // No es error, solo advertencia
    }
    
    Logger::instance().info(
        QString("Migraci√≥n requerida: v%1 -> v%2")
        .arg(currentVersion).arg(targetVersion)
    );
    
    // Aqu√≠ implementar√≠amos las migraciones incrementales
    // Por ahora, solo actualizamos la versi√≥n
    
    QSqlQuery query(m_database);
    query.prepare("UPDATE schema_info SET version = ?, updated_at = datetime('now', 'localtime') WHERE id = 1");
    query.addBindValue(targetVersion);
    
    if (!query.exec()) {
        logSqlError("Actualizar versi√≥n esquema", query.lastError());
        return DatabaseResult::error("Error actualizando versi√≥n del esquema");
    }
    
    emit migrationCompleted(currentVersion, targetVersion);
    Logger::instance().info(QString("‚úì Migraci√≥n completada a v%1").arg(targetVersion));
    
    return DatabaseResult::ok();
}

//==============================================================================
// Operaciones de base de datos
//==============================================================================
DatabaseResult DatabaseManager::execute(const QString& sql, const QVariantList& params) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_connected) {
        return DatabaseResult::error("Base de datos no conectada");
    }
    
    QSqlQuery query(m_database);
    query.prepare(sql);
    
    // Bind de par√°metros
    for (int i = 0; i < params.size(); ++i) {
        query.addBindValue(params[i]);
    }
    
    if (!query.exec()) {
        logSqlError("Execute", query.lastError());
        return DatabaseResult::error(query.lastError().text());
    }
    
    // Retornar el √∫ltimo ID insertado si aplica
    QVariant lastId = query.lastInsertId();
    return DatabaseResult::ok(lastId.isValid() ? lastId : QVariant(query.numRowsAffected()));
}

DatabaseResult DatabaseManager::executeScalar(const QString& sql, const QVariantList& params) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_connected) {
        return DatabaseResult::error("Base de datos no conectada");
    }
    
    QSqlQuery query(m_database);
    query.prepare(sql);
    
    for (int i = 0; i < params.size(); ++i) {
        query.addBindValue(params[i]);
    }
    
    if (!query.exec()) {
        logSqlError("ExecuteScalar", query.lastError());
        return DatabaseResult::error(query.lastError().text());
    }
    
    if (query.next()) {
        return DatabaseResult::ok(query.value(0));
    }
    
    return DatabaseResult::ok();  // Sin resultados, pero no es error
}

QList<QVariantMap> DatabaseManager::executeQuery(const QString& sql, const QVariantList& params) {
    QMutexLocker locker(&m_mutex);
    
    QList<QVariantMap> results;
    
    if (!m_connected) {
        Logger::instance().error("ExecuteQuery: Base de datos no conectada");
        return results;
    }
    
    QSqlQuery query(m_database);
    query.prepare(sql);
    
    for (int i = 0; i < params.size(); ++i) {
        query.addBindValue(params[i]);
    }
    
    if (!query.exec()) {
        logSqlError("ExecuteQuery", query.lastError());
        return results;
    }
    
    QSqlRecord record = query.record();
    int columnCount = record.count();
    
    while (query.next()) {
        QVariantMap row;
        for (int i = 0; i < columnCount; ++i) {
            row[record.fieldName(i)] = query.value(i);
        }
        results.append(row);
    }
    
    return results;
}

DatabaseResult DatabaseManager::executeTransaction(const QStringList& statements) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_connected) {
        return DatabaseResult::error("Base de datos no conectada");
    }
    
    if (!m_database.transaction()) {
        return DatabaseResult::error("No se pudo iniciar transacci√≥n");
    }
    
    QSqlQuery query(m_database);
    
    for (const QString& sql : statements) {
        if (!query.exec(sql)) {
            logSqlError("Transaction statement", query.lastError());
            m_database.rollback();
            return DatabaseResult::error(query.lastError().text());
        }
    }
    
    if (!m_database.commit()) {
        m_database.rollback();
        return DatabaseResult::error("Error en commit");
    }
    
    return DatabaseResult::ok();
}

DatabaseResult DatabaseManager::executeInTransaction(std::function<bool(QSqlQuery&)> func) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_connected) {
        return DatabaseResult::error("Base de datos no conectada");
    }
    
    if (!m_database.transaction()) {
        return DatabaseResult::error("No se pudo iniciar transacci√≥n");
    }
    
    QSqlQuery query(m_database);
    
    try {
        if (func(query)) {
            if (m_database.commit()) {
                return DatabaseResult::ok();
            }
            m_database.rollback();
            return DatabaseResult::error("Error en commit");
        } else {
            m_database.rollback();
            return DatabaseResult::error("Funci√≥n de transacci√≥n retorn√≥ false");
        }
    } catch (const std::exception& e) {
        m_database.rollback();
        return DatabaseResult::error(QString("Excepci√≥n: %1").arg(e.what()));
    }
}

//==============================================================================
// Utilidades
//==============================================================================
bool DatabaseManager::tableExists(const QString& tableName) {
    QMutexLocker locker(&m_mutex);
    
    QSqlQuery query(m_database);
    query.prepare(
        "SELECT COUNT(*) FROM sqlite_master "
        "WHERE type = 'table' AND name = ?"
    );
    query.addBindValue(tableName);
    
    if (query.exec() && query.next()) {
        return query.value(0).toInt() > 0;
    }
    
    return false;
}

int DatabaseManager::rowCount(const QString& tableName) {
    QMutexLocker locker(&m_mutex);
    
    // Sanitizaci√≥n b√°sica del nombre de tabla
    QString safeName = tableName;
    safeName.remove(QRegularExpression("[^a-zA-Z0-9_]"));
    
    QSqlQuery query(m_database);
    if (query.exec(QString("SELECT COUNT(*) FROM %1").arg(safeName)) && query.next()) {
        return query.value(0).toInt();
    }
    
    return -1;
}

qint64 DatabaseManager::lastInsertId() {
    QMutexLocker locker(&m_mutex);
    
    QSqlQuery query(m_database);
    if (query.exec("SELECT last_insert_rowid()") && query.next()) {
        return query.value(0).toLongLong();
    }
    
    return -1;
}

QSqlDatabase& DatabaseManager::database() {
    return m_database;
}

QSqlQuery DatabaseManager::createQuery() {
    return QSqlQuery(m_database);
}

DatabaseResult DatabaseManager::vacuum() {
    QMutexLocker locker(&m_mutex);
    
    QSqlQuery query(m_database);
    if (query.exec("VACUUM")) {
        Logger::instance().info("VACUUM ejecutado correctamente");
        return DatabaseResult::ok();
    }
    
    return DatabaseResult::error(query.lastError().text());
}

QVariantMap DatabaseManager::getStatistics() {
    QMutexLocker locker(&m_mutex);
    
    QVariantMap stats;
    stats["connected"] = m_connected;
    stats["path"] = m_config.path;
    stats["schemaVersion"] = Database::SCHEMA_VERSION;
    
    if (m_connected) {
        stats["productsCount"] = rowCount(Database::Tables::PRODUCTS);
        stats["salesCount"] = rowCount(Database::Tables::SALES);
        
        // Tama√±o del archivo
        QFileInfo fileInfo(m_config.path);
        stats["fileSizeBytes"] = fileInfo.size();
        stats["fileSizeMB"] = QString::number(fileInfo.size() / 1024.0 / 1024.0, 'f', 2);
    }
    
    return stats;
}

//==============================================================================
// Close
//==============================================================================
void DatabaseManager::close() {
    QMutexLocker locker(&m_mutex);
    
    if (m_connected && m_database.isOpen()) {
        m_database.close();
        m_connected = false;
        
        Logger::instance().info("Base de datos cerrada");
        emit connectionChanged(false);
    }
}

//==============================================================================
// Getters
//==============================================================================
bool DatabaseManager::isConnected() const {
    return m_connected && m_database.isOpen();
}

QString DatabaseManager::databasePath() const {
    return m_config.path;
}

int DatabaseManager::schemaVersion() const {
    return Database::SCHEMA_VERSION;
}

//==============================================================================
// Logging
//==============================================================================
void DatabaseManager::logSqlError(const QString& context, const QSqlError& error) {
    if (error.isValid()) {
        Logger::instance().error(
            QString("[SQL Error] %1\n"
                    "  Type: %2\n"
                    "  Database: %3\n"
                    "  Driver: %4")
            .arg(context)
            .arg(error.type())
            .arg(error.databaseText())
            .arg(error.driverText())
        );
        
        emit errorOccurred(error.text());
    }
}

} // namespace Vento
```

---

## üìÑ src/core/logger/Logger.hpp (Actualizado)

```cpp
//==============================================================================
// Logger.hpp
// Vento - Sistema de logging mejorado
//==============================================================================
#pragma once

#include <QObject>
#include <QString>
#include <QFile>
#include <QTextStream>
#include <QMutex>
#include <QDateTime>

#include <functional>

namespace Vento {

//==============================================================================
// Niveles de log
//==============================================================================
enum class LogLevel {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Fatal = 5
};

//==============================================================================
// Entrada de log
//==============================================================================
struct LogEntry {
    QDateTime timestamp;
    LogLevel level;
    QString message;
    QString category;
    QString file;
    int line;
};

//==============================================================================
// Logger Singleton
//==============================================================================
class Logger : public QObject {
    Q_OBJECT
    
public:
    using LogHandler = std::function<void(const LogEntry&)>;
    
    static Logger& instance();
    
    // Configuraci√≥n
    void setLogLevel(LogLevel level);
    void setLogToFile(const QString& filePath);
    void setLogToConsole(bool enabled);
    void addHandler(LogHandler handler);
    
    // M√©todos de log
    void log(LogLevel level, const QString& message, 
             const QString& category = {},
             const char* file = nullptr, int line = 0);
    
    // M√©todos convenientes
    void trace(const QString& message, const QString& category = {});
    void debug(const QString& message, const QString& category = {});
    void info(const QString& message, const QString& category = {});
    void warning(const QString& message, const QString& category = {});
    void error(const QString& message, const QString& category = {});
    void fatal(const QString& message, const QString& category = {});
    
    // Obtener nivel actual
    LogLevel logLevel() const { return m_level; }
    
    // Utilidades
    static QString levelToString(LogLevel level);
    static QString levelToEmoji(LogLevel level);
    
signals:
    void logMessage(const QString& formattedMessage);
    
private:
    Logger();
    ~Logger() override;
    
    void writeToFile(const QString& message);
    void writeToConsole(const LogEntry& entry);
    QString formatEntry(const LogEntry& entry);
    
    LogLevel m_level = LogLevel::Info;
    bool m_consoleEnabled = true;
    
    QFile m_logFile;
    QTextStream m_fileStream;
    mutable QMutex m_mutex;
    
    QList<LogHandler> m_handlers;
};

//==============================================================================
// Macros para logging con archivo y l√≠nea
//==============================================================================
#define VENTO_LOG(level, msg) \
    Vento::Logger::instance().log(level, msg, {}, __FILE__, __LINE__)

#define VENTO_TRACE(msg) VENTO_LOG(Vento::LogLevel::Trace, msg)
#define VENTO_DEBUG(msg) VENTO_LOG(Vento::LogLevel::Debug, msg)
#define VENTO_INFO(msg)  VENTO_LOG(Vento::LogLevel::Info, msg)
#define VENTO_WARN(msg)  VENTO_LOG(Vento::LogLevel::Warning, msg)
#define VENTO_ERROR(msg) VENTO_LOG(Vento::LogLevel::Error, msg)
#define VENTO_FATAL(msg) VENTO_LOG(Vento::LogLevel::Fatal, msg)

} // namespace Vento
```

---

## üìÑ src/core/logger/Logger.cpp (Actualizado)

```cpp
//==============================================================================
// Logger.cpp
// Vento - Implementaci√≥n del sistema de logging
//==============================================================================

#include "Logger.hpp"
#include <QDebug>
#include <QDir>
#include <QFileInfo>
#include <iostream>

namespace Vento {

Logger& Logger::instance() {
    static Logger instance;
    return instance;
}

Logger::Logger() : QObject(nullptr) {}

Logger::~Logger() {
    if (m_logFile.isOpen()) {
        m_logFile.close();
    }
}

void Logger::setLogLevel(LogLevel level) {
    QMutexLocker locker(&m_mutex);
    m_level = level;
}

void Logger::setLogToFile(const QString& filePath) {
    QMutexLocker locker(&m_mutex);
    
    if (m_logFile.isOpen()) {
        m_logFile.close();
    }
    
    // Crear directorio si no existe
    QFileInfo fileInfo(filePath);
    QDir dir = fileInfo.absoluteDir();
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    
    m_logFile.setFileName(filePath);
    if (m_logFile.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        m_fileStream.setDevice(&m_logFile);
        info(QString("Log file opened: %1").arg(filePath));
    } else {
        qWarning() << "Could not open log file:" << filePath;
    }
}

void Logger::setLogToConsole(bool enabled) {
    QMutexLocker locker(&m_mutex);
    m_consoleEnabled = enabled;
}

void Logger::addHandler(LogHandler handler) {
    QMutexLocker locker(&m_mutex);
    m_handlers.append(std::move(handler));
}

void Logger::log(LogLevel level, const QString& message, 
                 const QString& category, const char* file, int line) {
    if (level < m_level) {
        return;
    }
    
    QMutexLocker locker(&m_mutex);
    
    LogEntry entry{
        QDateTime::currentDateTime(),
        level,
        message,
        category,
        file ? QFileInfo(file).fileName() : QString(),
        line
    };
    
    QString formatted = formatEntry(entry);
    
    // Console output
    if (m_consoleEnabled) {
        writeToConsole(entry);
    }
    
    // File output
    if (m_logFile.isOpen()) {
        writeToFile(formatted);
    }
    
    // Custom handlers
    for (const auto& handler : m_handlers) {
        handler(entry);
    }
    
    emit logMessage(formatted);
}

QString Logger::formatEntry(const LogEntry& entry) {
    QString result = QString("[%1] [%2]")
        .arg(entry.timestamp.toString("yyyy-MM-dd hh:mm:ss.zzz"))
        .arg(levelToString(entry.level).leftJustified(7));
    
    if (!entry.category.isEmpty()) {
        result += QString(" [%1]").arg(entry.category);
    }
    
    result += QString(" %1").arg(entry.message);
    
    if (!entry.file.isEmpty()) {
        result += QString(" (%1:%2)").arg(entry.file).arg(entry.line);
    }
    
    return result;
}

void Logger::writeToFile(const QString& message) {
    m_fileStream << message << "\n";
    m_fileStream.flush();
}

void Logger::writeToConsole(const LogEntry& entry) {
    QString emoji = levelToEmoji(entry.level);
    QString output = QString("%1 %2").arg(emoji, entry.message);
    
    switch (entry.level) {
        case LogLevel::Trace:
        case LogLevel::Debug:
            qDebug().noquote() << output;
            break;
        case LogLevel::Info:
            qInfo().noquote() << output;
            break;
        case LogLevel::Warning:
            qWarning().noquote() << output;
            break;
        case LogLevel::Error:
        case LogLevel::Fatal:
            qCritical().noquote() << output;
            break;
    }
}

QString Logger::levelToString(LogLevel level) {
    switch (level) {
        case LogLevel::Trace:   return "TRACE";
        case LogLevel::Debug:   return "DEBUG";
        case LogLevel::Info:    return "INFO";
        case LogLevel::Warning: return "WARN";
        case LogLevel::Error:   return "ERROR";
        case LogLevel::Fatal:   return "FATAL";
        default:                return "UNKNOWN";
    }
}

QString Logger::levelToEmoji(LogLevel level) {
    switch (level) {
        case LogLevel::Trace:   return "üîç";
        case LogLevel::Debug:   return "üêõ";
        case LogLevel::Info:    return "‚ÑπÔ∏è ";
        case LogLevel::Warning: return "‚ö†Ô∏è ";
        case LogLevel::Error:   return "‚ùå";
        case LogLevel::Fatal:   return "üíÄ";
        default:                return "  ";
    }
}

// Convenience methods
void Logger::trace(const QString& message, const QString& category) {
    log(LogLevel::Trace, message, category);
}

void Logger::debug(const QString& message, const QString& category) {
    log(LogLevel::Debug, message, category);
}

void Logger::info(const QString& message, const QString& category) {
    log(LogLevel::Info, message, category);
}

void Logger::warning(const QString& message, const QString& category) {
    log(LogLevel::Warning, message, category);
}

void Logger::error(const QString& message, const QString& category) {
    log(LogLevel::Error, message, category);
}

void Logger::fatal(const QString& message, const QString& category) {
    log(LogLevel::Fatal, message, category);
}

} // namespace Vento
```

---

## üìÑ src/core/utils/Types.hpp

```cpp
//==============================================================================
// Types.hpp
// Vento - Tipos comunes del proyecto
//==============================================================================
#pragma once

#include <QString>
#include <QVariant>
#include <optional>
#include <cstdint>

namespace Vento {

//==============================================================================
// Alias de tipos comunes
//==============================================================================
using Id = qint64;
using Money = double;  // Podr√≠amos usar un tipo Decimal para precisi√≥n
using Percentage = double;

//==============================================================================
// Constantes del negocio
//==============================================================================
namespace Business {
    constexpr Money DEFAULT_EXCHANGE_RATE = 36.50;
    constexpr Percentage DEFAULT_TAX_PERCENT = 16.0;
    constexpr Percentage DEFAULT_MARGIN_PERCENT = 30.0;
    constexpr int DEFAULT_MIN_STOCK_ALERT = 5;
}

//==============================================================================
// Claves de configuraci√≥n
//==============================================================================
namespace SettingsKeys {
    constexpr auto EXCHANGE_RATE = "exchange_rate_usd";
    constexpr auto CURRENCY_LOCAL = "currency_symbol_local";
    constexpr auto CURRENCY_USD = "currency_symbol_usd";
    constexpr auto TAX_PERCENT = "tax_percent";
    constexpr auto STORE_NAME = "store_name";
    constexpr auto APP_THEME = "app_theme";
}

//==============================================================================
// Estados de venta
//==============================================================================
enum class SaleStatus {
    Pending,
    Completed,
    Cancelled,
    Refunded
};

inline QString saleStatusToString(SaleStatus status) {
    switch (status) {
        case SaleStatus::Pending:   return "pending";
        case SaleStatus::Completed: return "completed";
        case SaleStatus::Cancelled: return "cancelled";
        case SaleStatus::Refunded:  return "refunded";
        default:                    return "unknown";
    }
}

inline SaleStatus stringToSaleStatus(const QString& str) {
    if (str == "pending")   return SaleStatus::Pending;
    if (str == "cancelled") return SaleStatus::Cancelled;
    if (str == "refunded")  return SaleStatus::Refunded;
    return SaleStatus::Completed;
}

//==============================================================================
// M√©todos de pago
//==============================================================================
enum class PaymentMethod {
    Cash,
    Card,
    Transfer,
    Mixed,
    Credit
};

inline QString paymentMethodToString(PaymentMethod method) {
    switch (method) {
        case PaymentMethod::Cash:     return "cash";
        case PaymentMethod::Card:     return "card";
        case PaymentMethod::Transfer: return "transfer";
        case PaymentMethod::Mixed:    return "mixed";
        case PaymentMethod::Credit:   return "credit";
        default:                      return "cash";
    }
}

} // namespace Vento
```

---

## üìÑ src/core/CMakeLists.txt (Actualizado)

```cmake
#===============================================================================
# src/core/CMakeLists.txt
# Vento - Biblioteca Core
#===============================================================================

set(CORE_SOURCES
    database/DatabaseManager.cpp
    logger/Logger.cpp
)

set(CORE_HEADERS
    database/DatabaseManager.hpp
    database/DatabaseSchema.hpp
    logger/Logger.hpp
    utils/EventBus.hpp
    utils/Types.hpp
)

#===============================================================================
# Biblioteca est√°tica Core
#===============================================================================
add_library(VentoCore STATIC
    ${CORE_SOURCES}
    ${CORE_HEADERS}
)

# Alias para uso limpio
add_library(Vento::Core ALIAS VentoCore)

#===============================================================================
# Configuraci√≥n de la biblioteca
#===============================================================================
target_include_directories(VentoCore
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_CURRENT_SOURCE_DIR}/..
)

target_link_libraries(VentoCore
    PUBLIC
        Qt6::Core
        Qt6::Sql
)

# Features de C++20
target_compile_features(VentoCore PUBLIC cxx_std_20)

# Definiciones
target_compile_definitions(VentoCore
    PRIVATE
        QT_NO_CAST_FROM_ASCII
        QT_NO_CAST_TO_ASCII
)
```

---

## üìÑ Actualizaci√≥n de src/main.cpp

```cpp
//==============================================================================
// main.cpp
// Vento - Entry Point (actualizado para usar nuevo DatabaseManager)
//==============================================================================

#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include <QQuickStyle>
#include <QIcon>
#include <QDir>
#include <QStandardPaths>

// Core
#include "core/database/DatabaseManager.hpp"
#include "core/logger/Logger.hpp"
#include "core/utils/Types.hpp"

// Features
#include "features/currency/CurrencyService.hpp"
#include "features/inventory/InventoryService.hpp"
#include "features/sales/SalesService.hpp"

//==============================================================================
// Configuraci√≥n
//==============================================================================
namespace Config {
    constexpr auto APP_NAME = "Vento";
    constexpr auto ORG_NAME = "VentoApp";
    constexpr auto ORG_DOMAIN = "vento.app";
    constexpr auto APP_VERSION = "1.0.0";
}

//==============================================================================
// Obtener ruta de datos de la aplicaci√≥n
//==============================================================================
QString getAppDataPath() {
    QString dataPath = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    QDir dir(dataPath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return dataPath;
}

//==============================================================================
// Configuraci√≥n del estilo visual
//==============================================================================
void setupApplicationStyle() {
    QQuickStyle::setStyle("Material");
    qputenv("QT_QUICK_CONTROLS_MATERIAL_VARIANT", "Dense");
    qputenv("QT_QUICK_CONTROLS_MATERIAL_THEME", "Light");
    qputenv("QT_QUICK_CONTROLS_MATERIAL_ACCENT", "#0078D4");
    qputenv("QT_QUICK_CONTROLS_MATERIAL_PRIMARY", "#005A9E");
}

//==============================================================================
// Inicializaci√≥n de servicios
//==============================================================================
bool initializeServices() {
    auto& logger = Vento::Logger::instance();
    auto& db = Vento::DatabaseManager::instance();
    
    // Configurar logger
    logger.setLogLevel(Vento::LogLevel::Debug);
    
    QString logPath = getAppDataPath() + "/logs/vento.log";
    logger.setLogToFile(logPath);
    
    logger.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    logger.info(QString("  Vento v%1 iniciando...").arg(Config::APP_VERSION));
    logger.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    
    // Inicializar base de datos
    QString dbPath = getAppDataPath() + "/vento.db";
    
    Vento::DatabaseConfig dbConfig;
    dbConfig.path = dbPath;
    dbConfig.enableForeignKeys = true;
    dbConfig.enableWAL = true;
    
    auto dbResult = db.initialize(dbConfig);
    if (!dbResult) {
        logger.error(QString("Error de base de datos: %1").arg(dbResult.errorMessage));
        return false;
    }
    
    // Mostrar estad√≠sticas
    auto stats = db.getStatistics();
    logger.info(QString("Base de datos: %1").arg(stats["path"].toString()));
    logger.info(QString("  Productos: %1").arg(stats["productsCount"].toInt()));
    logger.info(QString("  Ventas: %1").arg(stats["salesCount"].toInt()));
    logger.info(QString("  Tama√±o: %1 MB").arg(stats["fileSizeMB"].toString()));
    
    // Inicializar features
    Vento::CurrencyService::instance().initialize();
    Vento::InventoryService::instance().initialize();
    Vento::SalesService::instance().initialize();
    
    logger.info("‚úì Todos los servicios inicializados correctamente");
    return true;
}

//==============================================================================
// Registro de tipos QML
//==============================================================================
void registerQmlTypes() {
    // DatabaseManager expuesto para estad√≠sticas
    qmlRegisterSingletonType<Vento::DatabaseManager>(
        "Vento.Core", 1, 0, "Database",
        [](QQmlEngine*, QJSEngine*) -> QObject* {
            return &Vento::DatabaseManager::instance();
        }
    );
    
    // Currency
    qmlRegisterSingletonType<Vento::CurrencyService>(
        "Vento.Currency", 1, 0, "CurrencyService",
        [](QQmlEngine*, QJSEngine*) -> QObject* {
            return &Vento::CurrencyService::instance();
        }
    );
    
    // Inventory
    qmlRegisterSingletonType<Vento::InventoryService>(
        "Vento.Inventory", 1, 0, "InventoryService",
        [](QQmlEngine*, QJSEngine*) -> QObject* {
            return &Vento::InventoryService::instance();
        }
    );
    
    // Sales
    qmlRegisterSingletonType<Vento::SalesService>(
        "Vento.Sales", 1, 0, "SalesService",
        [](QQmlEngine*, QJSEngine*) -> QObject* {
            return &Vento::SalesService::instance();
        }
    );
}

//==============================================================================
// Main
//==============================================================================
int main(int argc, char *argv[]) {
    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(
        Qt::HighDpiScaleFactorRoundingPolicy::PassThrough
    );
    
    QGuiApplication app(argc, argv);
    
    app.setApplicationName(Config::APP_NAME);
    app.setOrganizationName(Config::ORG_NAME);
    app.setOrganizationDomain(Config::ORG_DOMAIN);
    app.setApplicationVersion(Config::APP_VERSION);
    app.setWindowIcon(QIcon(":/icons/app_icon.png"));
    
    setupApplicationStyle();
    registerQmlTypes();
    
    if (!initializeServices()) {
        qCritical() << "Error cr√≠tico: No se pudieron inicializar los servicios";
        return -1;
    }
    
    QQmlApplicationEngine engine;
    
    engine.addImportPath(":/");
    engine.rootContext()->setContextProperty("appVersion", Config::APP_VERSION);
    engine.rootContext()->setContextProperty("appName", Config::APP_NAME);
    
    const QUrl mainQml(QStringLiteral("qrc:/qml/Main.qml"));
    
    QObject::connect(
        &engine,
        &QQmlApplicationEngine::objectCreationFailed,
        &app,
        []() { QCoreApplication::exit(-1); },
        Qt::QueuedConnection
    );
    
    engine.load(mainQml);
    
    if (engine.rootObjects().isEmpty()) {
        return -1;
    }
    
    Vento::Logger::instance().info("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    Vento::Logger::instance().info("‚ïë     üåä Vento iniciado correctamente   ‚ïë");
    Vento::Logger::instance().info("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
    
    return app.exec();
}
```

---

## üß™ Ejemplo de Uso del DatabaseManager

```cpp
// Ejemplo de c√≥mo usar DatabaseManager en otros servicios

#include "core/database/DatabaseManager.hpp"

void ejemploDeUso() {
    auto& db = Vento::DatabaseManager::instance();
    
    // 1. Insertar un producto
    auto result = db.execute(
        "INSERT INTO products (name, cost_usd, margin_percent, sale_price) "
        "VALUES (?, ?, ?, ?)",
        {"Laptop HP", 500.0, 30.0, 650.0}
    );
    
    if (result) {
        qDebug() << "Producto insertado con ID:" << result.data.toLongLong();
    }
    
    // 2. Consultar productos
    auto products = db.executeQuery(
        "SELECT * FROM products WHERE is_active = ?",
        {1}
    );
    
    for (const auto& product : products) {
        qDebug() << "Producto:" << product["name"].toString()
                 << "Precio:" << product["sale_price"].toDouble();
    }
    
    // 3. Obtener configuraci√≥n
    auto rateResult = db.executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {"exchange_rate_usd"}
    );
    
    if (rateResult) {
        double rate = rateResult.data.toDouble();
        qDebug() << "Tasa de cambio:" << rate;
    }
    
    // 4. Transacci√≥n compleja
    auto transResult = db.executeInTransaction([](QSqlQuery& query) {
        query.prepare("UPDATE products SET stock_quantity = stock_quantity - ? WHERE id = ?");
        query.addBindValue(1);
        query.addBindValue(1);
        
        if (!query.exec()) return false;
        
        query.prepare("INSERT INTO sales (total, exchange_rate) VALUES (?, ?)");
        query.addBindValue(650.0);
        query.addBindValue(36.50);
        
        return query.exec();
    });
    
    if (transResult) {
        qDebug() << "Venta registrada correctamente";
    }
}
```

---

## üìä Diagrama del Esquema de Base de Datos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         VENTO DATABASE SCHEMA                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   schema_info   ‚îÇ       ‚îÇ    settings     ‚îÇ       ‚îÇ   products     ‚îÇ ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ
‚îÇ  ‚îÇ id (PK)         ‚îÇ       ‚îÇ key (PK)        ‚îÇ       ‚îÇ id (PK)        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ version         ‚îÇ       ‚îÇ value           ‚îÇ       ‚îÇ name           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ created_at      ‚îÇ       ‚îÇ description     ‚îÇ       ‚îÇ description    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ updated_at      ‚îÇ       ‚îÇ updated_at      ‚îÇ       ‚îÇ sku            ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ barcode        ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ category       ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ cost_usd       ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ cost_local     ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ margin_percent ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ sale_price     ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ stock_quantity ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ min_stock_alert‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ is_active      ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ created_at     ‚îÇ ‚îÇ
‚îÇ                                                       ‚îÇ updated_at     ‚îÇ ‚îÇ
‚îÇ                                                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                               ‚îÇ          ‚îÇ
‚îÇ                                                               ‚îÇ FK       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ                      sales                           ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ id (PK)          ‚îÇ payment_method                   ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ sale_date        ‚îÇ customer_name                    ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ subtotal         ‚îÇ customer_id                      ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ tax_percent      ‚îÇ status                           ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ tax_amount       ‚îÇ notes                            ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ discount_amount  ‚îÇ created_at                       ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ total            ‚îÇ                                  ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ exchange_rate    ‚îÇ                                  ‚îÇ     ‚îÇ          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ          ‚îÇ
‚îÇ            ‚îÇ                                                  ‚îÇ          ‚îÇ
‚îÇ            ‚îÇ FK                                               ‚îÇ          ‚îÇ
‚îÇ            ‚ñº                                                  ‚ñº          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ                         sale_items                                   ‚îÇ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ
‚îÇ  ‚îÇ id (PK)  ‚îÇ sale_id (FK) ‚îÇ product_id (FK) ‚îÇ product_name            ‚îÇ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ              ‚îÇ                  ‚îÇ unit_price ‚îÇ quantity   ‚îÇ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ              ‚îÇ                  ‚îÇ subtotal   ‚îÇ created_at ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

¬øContinuamos con la implementaci√≥n del **Feature Currency** (gesti√≥n de tasa de cambio) con el patr√≥n Observer para notificar cambios al inventario? üöÄ
