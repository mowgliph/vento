# Vento - Feature Currency (Gesti√≥n de Tasa de Cambio)

Implementaremos el Feature Currency siguiendo SOLID y el patr√≥n Observer de Qt.

## üìÅ Estructura del Feature

```
src/features/currency/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ CurrencyTypes.hpp          # Tipos y constantes
‚îú‚îÄ‚îÄ CurrencyModel.hpp          # Modelo de datos
‚îú‚îÄ‚îÄ CurrencyRepository.hpp     # Capa de persistencia (SRP)
‚îú‚îÄ‚îÄ CurrencyRepository.cpp
‚îú‚îÄ‚îÄ CurrencyService.hpp        # Servicio expuesto a QML
‚îî‚îÄ‚îÄ CurrencyService.cpp
```

---

## üìÑ src/features/currency/CurrencyTypes.hpp

```cpp
//==============================================================================
// CurrencyTypes.hpp
// Vento - Tipos y constantes para el m√≥dulo Currency
//==============================================================================
#pragma once

#include <QString>
#include <QObject>

namespace Vento::Currency {

//==============================================================================
// Constantes del m√≥dulo
//==============================================================================
namespace Defaults {
    constexpr double EXCHANGE_RATE_USD = 36.50;
    constexpr double MIN_EXCHANGE_RATE = 0.01;
    constexpr double MAX_EXCHANGE_RATE = 1000000.0;
}

//==============================================================================
// Claves de configuraci√≥n en BD
//==============================================================================
namespace SettingsKeys {
    constexpr auto EXCHANGE_RATE_USD = "exchange_rate_usd";
    constexpr auto CURRENCY_SYMBOL_LOCAL = "currency_symbol_local";
    constexpr auto CURRENCY_SYMBOL_USD = "currency_symbol_usd";
    constexpr auto LAST_RATE_UPDATE = "last_rate_update";
    constexpr auto RATE_UPDATE_SOURCE = "rate_update_source";
}

//==============================================================================
// C√≥digos de moneda
//==============================================================================
enum class CurrencyCode {
    USD,    // D√≥lar estadounidense
    VES,    // Bol√≠var venezolano
    EUR,    // Euro
    COP,    // Peso colombiano
    BRL     // Real brasile√±o
};

inline QString currencyCodeToString(CurrencyCode code) {
    switch (code) {
        case CurrencyCode::USD: return "USD";
        case CurrencyCode::VES: return "VES";
        case CurrencyCode::EUR: return "EUR";
        case CurrencyCode::COP: return "COP";
        case CurrencyCode::BRL: return "BRL";
        default: return "USD";
    }
}

inline QString currencySymbol(CurrencyCode code) {
    switch (code) {
        case CurrencyCode::USD: return "$";
        case CurrencyCode::VES: return "Bs.";
        case CurrencyCode::EUR: return "‚Ç¨";
        case CurrencyCode::COP: return "$";
        case CurrencyCode::BRL: return "R$";
        default: return "$";
    }
}

//==============================================================================
// Fuente de actualizaci√≥n de tasa
//==============================================================================
enum class RateUpdateSource {
    Manual,         // Ingresado manualmente
    BCV,            // Banco Central de Venezuela
    DolarToday,     // DolarToday
    Binance,        // Binance P2P
    Custom          // API personalizada
};

inline QString rateSourceToString(RateUpdateSource source) {
    switch (source) {
        case RateUpdateSource::Manual:     return "manual";
        case RateUpdateSource::BCV:        return "bcv";
        case RateUpdateSource::DolarToday: return "dolartoday";
        case RateUpdateSource::Binance:    return "binance";
        case RateUpdateSource::Custom:     return "custom";
        default: return "manual";
    }
}

} // namespace Vento::Currency
```

---

## üìÑ src/features/currency/CurrencyModel.hpp

```cpp
//==============================================================================
// CurrencyModel.hpp
// Vento - Modelo de datos para informaci√≥n de moneda
//==============================================================================
#pragma once

#include <QObject>
#include <QString>
#include <QDateTime>
#include <QJsonObject>

#include "CurrencyTypes.hpp"

namespace Vento {

//==============================================================================
// ExchangeRateInfo - Informaci√≥n completa de tasa de cambio
//==============================================================================
struct ExchangeRateInfo {
    double rate = Currency::Defaults::EXCHANGE_RATE_USD;
    QDateTime lastUpdate;
    Currency::RateUpdateSource source = Currency::RateUpdateSource::Manual;
    QString sourceDescription;
    
    // Serializaci√≥n
    QJsonObject toJson() const {
        return {
            {"rate", rate},
            {"lastUpdate", lastUpdate.toString(Qt::ISODate)},
            {"source", Currency::rateSourceToString(source)},
            {"sourceDescription", sourceDescription}
        };
    }
    
    static ExchangeRateInfo fromJson(const QJsonObject& json) {
        ExchangeRateInfo info;
        info.rate = json["rate"].toDouble(Currency::Defaults::EXCHANGE_RATE_USD);
        info.lastUpdate = QDateTime::fromString(json["lastUpdate"].toString(), Qt::ISODate);
        info.sourceDescription = json["sourceDescription"].toString();
        return info;
    }
    
    // Validaci√≥n
    bool isValid() const {
        return rate >= Currency::Defaults::MIN_EXCHANGE_RATE && 
               rate <= Currency::Defaults::MAX_EXCHANGE_RATE;
    }
};

//==============================================================================
// CurrencyInfo - Informaci√≥n de una moneda
//==============================================================================
struct CurrencyInfo {
    Currency::CurrencyCode code;
    QString symbol;
    QString name;
    QString country;
    int decimals = 2;
    
    static CurrencyInfo USD() {
        return {Currency::CurrencyCode::USD, "$", "D√≥lar Estadounidense", "USA", 2};
    }
    
    static CurrencyInfo VES() {
        return {Currency::CurrencyCode::VES, "Bs.", "Bol√≠var", "Venezuela", 2};
    }
};

//==============================================================================
// RateHistoryEntry - Entrada del historial de tasas
//==============================================================================
struct RateHistoryEntry {
    qint64 id = 0;
    double rate = 0.0;
    QDateTime timestamp;
    Currency::RateUpdateSource source = Currency::RateUpdateSource::Manual;
    double previousRate = 0.0;
    double changePercent = 0.0;
    
    // Calcular porcentaje de cambio
    void calculateChange() {
        if (previousRate > 0) {
            changePercent = ((rate - previousRate) / previousRate) * 100.0;
        }
    }
};

} // namespace Vento

// Registrar tipos para uso en Qt meta-system
Q_DECLARE_METATYPE(Vento::ExchangeRateInfo)
Q_DECLARE_METATYPE(Vento::CurrencyInfo)
Q_DECLARE_METATYPE(Vento::RateHistoryEntry)
```

---

## üìÑ src/features/currency/CurrencyRepository.hpp

```cpp
//==============================================================================
// CurrencyRepository.hpp
// Vento - Repositorio para persistencia de datos de moneda
//
// Principio: Single Responsibility
// Esta clase SOLO se encarga de operaciones de base de datos
//==============================================================================
#pragma once

#include <QObject>
#include <QString>
#include <QList>
#include <optional>

#include "CurrencyModel.hpp"
#include "CurrencyTypes.hpp"

namespace Vento {

class CurrencyRepository : public QObject {
    Q_OBJECT
    
public:
    explicit CurrencyRepository(QObject* parent = nullptr);
    ~CurrencyRepository() override = default;
    
    //--------------------------------------------------------------------------
    // Operaciones de tasa de cambio
    //--------------------------------------------------------------------------
    
    /// Guarda la tasa de cambio actual
    /// @param rate Nueva tasa de cambio
    /// @param source Fuente de la actualizaci√≥n
    /// @return true si se guard√≥ correctamente
    [[nodiscard]] bool saveExchangeRate(
        double rate, 
        Currency::RateUpdateSource source = Currency::RateUpdateSource::Manual
    );
    
    /// Obtiene la tasa de cambio actual
    /// @return Tasa actual o valor por defecto si no existe
    [[nodiscard]] double getExchangeRate() const;
    
    /// Obtiene informaci√≥n completa de la tasa
    /// @return Estructura con toda la informaci√≥n
    [[nodiscard]] ExchangeRateInfo getExchangeRateInfo() const;
    
    //--------------------------------------------------------------------------
    // Configuraci√≥n de moneda
    //--------------------------------------------------------------------------
    
    /// Obtiene el s√≠mbolo de moneda local
    [[nodiscard]] QString getLocalCurrencySymbol() const;
    
    /// Establece el s√≠mbolo de moneda local
    bool setLocalCurrencySymbol(const QString& symbol);
    
    /// Obtiene el s√≠mbolo de USD
    [[nodiscard]] QString getUsdSymbol() const;
    
    //--------------------------------------------------------------------------
    // Historial de tasas
    //--------------------------------------------------------------------------
    
    /// Guarda una entrada en el historial
    bool saveRateHistory(const RateHistoryEntry& entry);
    
    /// Obtiene el historial de tasas
    /// @param limit N√∫mero m√°ximo de registros (0 = todos)
    /// @return Lista de entradas del historial
    [[nodiscard]] QList<RateHistoryEntry> getRateHistory(int limit = 30) const;
    
    /// Obtiene la √∫ltima tasa registrada en el historial
    [[nodiscard]] std::optional<RateHistoryEntry> getLastRateEntry() const;
    
    /// Limpia el historial antiguo (m√°s de N d√≠as)
    bool cleanOldHistory(int daysToKeep = 90);
    
    //--------------------------------------------------------------------------
    // Utilidades
    //--------------------------------------------------------------------------
    
    /// Obtiene un valor de configuraci√≥n
    [[nodiscard]] QString getSetting(const QString& key, const QString& defaultValue = {}) const;
    
    /// Guarda un valor de configuraci√≥n
    bool setSetting(const QString& key, const QString& value);
    
private:
    /// Asegura que existe la tabla de historial
    void ensureHistoryTableExists();
};

} // namespace Vento
```

---

## üìÑ src/features/currency/CurrencyRepository.cpp

```cpp
//==============================================================================
// CurrencyRepository.cpp
// Vento - Implementaci√≥n del repositorio de moneda
//==============================================================================

#include "CurrencyRepository.hpp"
#include "core/database/DatabaseManager.hpp"
#include "core/logger/Logger.hpp"

#include <QDateTime>
#include <QSqlQuery>
#include <QSqlError>

namespace Vento {

//==============================================================================
// Constructor
//==============================================================================
CurrencyRepository::CurrencyRepository(QObject* parent) 
    : QObject(parent) 
{
    ensureHistoryTableExists();
    Logger::instance().debug("CurrencyRepository inicializado", "Currency");
}

//==============================================================================
// Tasa de cambio
//==============================================================================
bool CurrencyRepository::saveExchangeRate(double rate, Currency::RateUpdateSource source) {
    auto& db = DatabaseManager::instance();
    
    // Validar rango
    if (rate < Currency::Defaults::MIN_EXCHANGE_RATE || 
        rate > Currency::Defaults::MAX_EXCHANGE_RATE) {
        Logger::instance().warning(
            QString("Tasa de cambio fuera de rango: %1").arg(rate), 
            "Currency"
        );
        return false;
    }
    
    // Obtener tasa anterior para el historial
    double previousRate = getExchangeRate();
    
    // Actualizar en settings
    auto result = db.execute(
        R"(
            INSERT INTO settings (key, value, description, updated_at)
            VALUES (?, ?, ?, datetime('now', 'localtime'))
            ON CONFLICT(key) DO UPDATE SET 
                value = excluded.value,
                updated_at = datetime('now', 'localtime')
        )",
        {
            Currency::SettingsKeys::EXCHANGE_RATE_USD,
            QString::number(rate, 'f', 4),
            "Tasa de cambio USD a moneda local"
        }
    );
    
    if (!result) {
        Logger::instance().error(
            QString("Error guardando tasa de cambio: %1").arg(result.errorMessage),
            "Currency"
        );
        return false;
    }
    
    // Guardar fuente de actualizaci√≥n
    db.execute(
        R"(
            INSERT INTO settings (key, value, updated_at)
            VALUES (?, ?, datetime('now', 'localtime'))
            ON CONFLICT(key) DO UPDATE SET 
                value = excluded.value,
                updated_at = datetime('now', 'localtime')
        )",
        {
            Currency::SettingsKeys::RATE_UPDATE_SOURCE,
            Currency::rateSourceToString(source)
        }
    );
    
    // Guardar en historial
    RateHistoryEntry historyEntry;
    historyEntry.rate = rate;
    historyEntry.timestamp = QDateTime::currentDateTime();
    historyEntry.source = source;
    historyEntry.previousRate = previousRate;
    historyEntry.calculateChange();
    
    saveRateHistory(historyEntry);
    
    Logger::instance().info(
        QString("Tasa de cambio actualizada: %1 (fuente: %2, cambio: %3%)")
            .arg(rate, 0, 'f', 4)
            .arg(Currency::rateSourceToString(source))
            .arg(historyEntry.changePercent, 0, 'f', 2),
        "Currency"
    );
    
    return true;
}

double CurrencyRepository::getExchangeRate() const {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {Currency::SettingsKeys::EXCHANGE_RATE_USD}
    );
    
    if (result && result.data.isValid()) {
        bool ok;
        double rate = result.data.toString().toDouble(&ok);
        if (ok && rate > 0) {
            return rate;
        }
    }
    
    return Currency::Defaults::EXCHANGE_RATE_USD;
}

ExchangeRateInfo CurrencyRepository::getExchangeRateInfo() const {
    auto& db = DatabaseManager::instance();
    ExchangeRateInfo info;
    
    // Obtener tasa
    info.rate = getExchangeRate();
    
    // Obtener √∫ltima actualizaci√≥n
    auto updateResult = db.executeScalar(
        "SELECT updated_at FROM settings WHERE key = ?",
        {Currency::SettingsKeys::EXCHANGE_RATE_USD}
    );
    
    if (updateResult && updateResult.data.isValid()) {
        info.lastUpdate = QDateTime::fromString(
            updateResult.data.toString(), 
            "yyyy-MM-dd hh:mm:ss"
        );
    }
    
    // Obtener fuente
    auto sourceResult = db.executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {Currency::SettingsKeys::RATE_UPDATE_SOURCE}
    );
    
    if (sourceResult && sourceResult.data.isValid()) {
        QString sourceStr = sourceResult.data.toString();
        if (sourceStr == "bcv") info.source = Currency::RateUpdateSource::BCV;
        else if (sourceStr == "dolartoday") info.source = Currency::RateUpdateSource::DolarToday;
        else if (sourceStr == "binance") info.source = Currency::RateUpdateSource::Binance;
        else info.source = Currency::RateUpdateSource::Manual;
    }
    
    return info;
}

//==============================================================================
// S√≠mbolos de moneda
//==============================================================================
QString CurrencyRepository::getLocalCurrencySymbol() const {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {Currency::SettingsKeys::CURRENCY_SYMBOL_LOCAL}
    );
    
    if (result && result.data.isValid()) {
        return result.data.toString();
    }
    
    return "Bs.";
}

bool CurrencyRepository::setLocalCurrencySymbol(const QString& symbol) {
    auto result = DatabaseManager::instance().execute(
        R"(
            INSERT INTO settings (key, value, updated_at)
            VALUES (?, ?, datetime('now', 'localtime'))
            ON CONFLICT(key) DO UPDATE SET 
                value = excluded.value,
                updated_at = datetime('now', 'localtime')
        )",
        {Currency::SettingsKeys::CURRENCY_SYMBOL_LOCAL, symbol}
    );
    
    return result.success;
}

QString CurrencyRepository::getUsdSymbol() const {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {Currency::SettingsKeys::CURRENCY_SYMBOL_USD}
    );
    
    if (result && result.data.isValid()) {
        return result.data.toString();
    }
    
    return "$";
}

//==============================================================================
// Historial
//==============================================================================
void CurrencyRepository::ensureHistoryTableExists() {
    DatabaseManager::instance().execute(R"(
        CREATE TABLE IF NOT EXISTS rate_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            rate REAL NOT NULL,
            timestamp TEXT NOT NULL DEFAULT (datetime('now', 'localtime')),
            source TEXT DEFAULT 'manual',
            previous_rate REAL,
            change_percent REAL
        )
    )");
    
    DatabaseManager::instance().execute(
        "CREATE INDEX IF NOT EXISTS idx_rate_history_timestamp ON rate_history(timestamp)"
    );
}

bool CurrencyRepository::saveRateHistory(const RateHistoryEntry& entry) {
    auto result = DatabaseManager::instance().execute(
        R"(
            INSERT INTO rate_history (rate, timestamp, source, previous_rate, change_percent)
            VALUES (?, ?, ?, ?, ?)
        )",
        {
            entry.rate,
            entry.timestamp.toString("yyyy-MM-dd hh:mm:ss"),
            Currency::rateSourceToString(entry.source),
            entry.previousRate,
            entry.changePercent
        }
    );
    
    return result.success;
}

QList<RateHistoryEntry> CurrencyRepository::getRateHistory(int limit) const {
    QString sql = R"(
        SELECT id, rate, timestamp, source, previous_rate, change_percent
        FROM rate_history
        ORDER BY timestamp DESC
    )";
    
    if (limit > 0) {
        sql += QString(" LIMIT %1").arg(limit);
    }
    
    auto rows = DatabaseManager::instance().executeQuery(sql);
    
    QList<RateHistoryEntry> history;
    history.reserve(rows.size());
    
    for (const auto& row : rows) {
        RateHistoryEntry entry;
        entry.id = row["id"].toLongLong();
        entry.rate = row["rate"].toDouble();
        entry.timestamp = QDateTime::fromString(
            row["timestamp"].toString(), 
            "yyyy-MM-dd hh:mm:ss"
        );
        entry.previousRate = row["previous_rate"].toDouble();
        entry.changePercent = row["change_percent"].toDouble();
        
        QString sourceStr = row["source"].toString();
        if (sourceStr == "bcv") entry.source = Currency::RateUpdateSource::BCV;
        else if (sourceStr == "dolartoday") entry.source = Currency::RateUpdateSource::DolarToday;
        else entry.source = Currency::RateUpdateSource::Manual;
        
        history.append(entry);
    }
    
    return history;
}

std::optional<RateHistoryEntry> CurrencyRepository::getLastRateEntry() const {
    auto history = getRateHistory(1);
    if (!history.isEmpty()) {
        return history.first();
    }
    return std::nullopt;
}

bool CurrencyRepository::cleanOldHistory(int daysToKeep) {
    auto result = DatabaseManager::instance().execute(
        R"(
            DELETE FROM rate_history 
            WHERE timestamp < datetime('now', ? || ' days')
        )",
        {QString("-%1").arg(daysToKeep)}
    );
    
    if (result) {
        int deleted = result.data.toInt();
        if (deleted > 0) {
            Logger::instance().info(
                QString("Historial de tasas limpiado: %1 registros eliminados").arg(deleted),
                "Currency"
            );
        }
    }
    
    return result.success;
}

//==============================================================================
// Utilidades
//==============================================================================
QString CurrencyRepository::getSetting(const QString& key, const QString& defaultValue) const {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT value FROM settings WHERE key = ?",
        {key}
    );
    
    if (result && result.data.isValid()) {
        return result.data.toString();
    }
    
    return defaultValue;
}

bool CurrencyRepository::setSetting(const QString& key, const QString& value) {
    auto result = DatabaseManager::instance().execute(
        R"(
            INSERT INTO settings (key, value, updated_at)
            VALUES (?, ?, datetime('now', 'localtime'))
            ON CONFLICT(key) DO UPDATE SET 
                value = excluded.value,
                updated_at = datetime('now', 'localtime')
        )",
        {key, value}
    );
    
    return result.success;
}

} // namespace Vento
```

---

## üìÑ src/features/currency/CurrencyService.hpp

```cpp
//==============================================================================
// CurrencyService.hpp
// Vento - Servicio de gesti√≥n de moneda expuesto a QML
//
// Este servicio act√∫a como fachada (Facade Pattern) para el m√≥dulo Currency
// y usa el patr√≥n Observer a trav√©s de Qt Signals/Slots
//==============================================================================
#pragma once

#include <QObject>
#include <QString>
#include <QQmlEngine>
#include <QVariantList>
#include <QVariantMap>
#include <memory>

#include "CurrencyModel.hpp"
#include "CurrencyTypes.hpp"
#include "CurrencyRepository.hpp"

namespace Vento {

class CurrencyService : public QObject {
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    
    //--------------------------------------------------------------------------
    // Propiedades QML
    //--------------------------------------------------------------------------
    
    /// Tasa de cambio actual
    Q_PROPERTY(double exchangeRate 
               READ exchangeRate 
               WRITE setExchangeRate 
               NOTIFY exchangeRateChanged)
    
    /// Tasa formateada para mostrar
    Q_PROPERTY(QString exchangeRateFormatted 
               READ exchangeRateFormatted 
               NOTIFY exchangeRateChanged)
    
    /// S√≠mbolo de moneda local
    Q_PROPERTY(QString localCurrencySymbol 
               READ localCurrencySymbol 
               WRITE setLocalCurrencySymbol 
               NOTIFY localCurrencySymbolChanged)
    
    /// S√≠mbolo de USD
    Q_PROPERTY(QString usdSymbol 
               READ usdSymbol 
               CONSTANT)
    
    /// √öltima actualizaci√≥n formateada
    Q_PROPERTY(QString lastUpdateFormatted 
               READ lastUpdateFormatted 
               NOTIFY exchangeRateChanged)
    
    /// Porcentaje de cambio respecto a la tasa anterior
    Q_PROPERTY(double changePercent 
               READ changePercent 
               NOTIFY exchangeRateChanged)
    
    /// Indica si la tasa subi√≥, baj√≥ o se mantuvo
    Q_PROPERTY(QString trend 
               READ trend 
               NOTIFY exchangeRateChanged)
    
public:
    //--------------------------------------------------------------------------
    // Singleton
    //--------------------------------------------------------------------------
    static CurrencyService& instance();
    
    /// Para uso con QML singleton
    static CurrencyService* create(QQmlEngine* engine, QJSEngine* scriptEngine);
    
    // Prevent copying
    CurrencyService(const CurrencyService&) = delete;
    CurrencyService& operator=(const CurrencyService&) = delete;
    
    //--------------------------------------------------------------------------
    // Inicializaci√≥n
    //--------------------------------------------------------------------------
    
    /// Inicializa el servicio (cargar datos de BD)
    void initialize();
    
    //--------------------------------------------------------------------------
    // Propiedades - Getters
    //--------------------------------------------------------------------------
    
    /// Obtiene la tasa de cambio actual
    [[nodiscard]] double exchangeRate() const;
    
    /// Obtiene la tasa formateada (ej: "36.50")
    [[nodiscard]] QString exchangeRateFormatted() const;
    
    /// Obtiene el s√≠mbolo de moneda local
    [[nodiscard]] QString localCurrencySymbol() const;
    
    /// Obtiene el s√≠mbolo de USD
    [[nodiscard]] QString usdSymbol() const;
    
    /// Obtiene la √∫ltima actualizaci√≥n formateada
    [[nodiscard]] QString lastUpdateFormatted() const;
    
    /// Obtiene el porcentaje de cambio
    [[nodiscard]] double changePercent() const;
    
    /// Obtiene la tendencia ("up", "down", "stable")
    [[nodiscard]] QString trend() const;
    
    //--------------------------------------------------------------------------
    // Propiedades - Setters
    //--------------------------------------------------------------------------
    
    /// Establece la tasa de cambio
    void setExchangeRate(double rate);
    
    /// Establece el s√≠mbolo de moneda local
    void setLocalCurrencySymbol(const QString& symbol);
    
    //--------------------------------------------------------------------------
    // M√©todos Q_INVOKABLE (accesibles desde QML)
    //--------------------------------------------------------------------------
    
    /// Actualiza la tasa de cambio manualmente
    Q_INVOKABLE bool updateRate(double newRate);
    
    /// Actualiza la tasa desde una fuente espec√≠fica
    Q_INVOKABLE bool updateRateFromSource(double newRate, const QString& source);
    
    /// Convierte de USD a moneda local
    Q_INVOKABLE double convertToLocal(double amountUsd) const;
    
    /// Convierte de moneda local a USD
    Q_INVOKABLE double convertToUsd(double amountLocal) const;
    
    /// Formatea un monto en moneda local
    Q_INVOKABLE QString formatLocal(double amount) const;
    
    /// Formatea un monto en USD
    Q_INVOKABLE QString formatUsd(double amount) const;
    
    /// Formatea un monto con s√≠mbolo personalizado
    Q_INVOKABLE QString formatAmount(double amount, const QString& symbol, int decimals = 2) const;
    
    /// Calcula el precio de venta basado en costo USD y margen
    Q_INVOKABLE double calculateSalePrice(double costUsd, double marginPercent) const;
    
    /// Obtiene el historial de tasas para gr√°ficos
    Q_INVOKABLE QVariantList getRateHistory(int limit = 30) const;
    
    /// Obtiene informaci√≥n completa de la tasa actual
    Q_INVOKABLE QVariantMap getRateInfo() const;
    
    /// Limpia el historial antiguo
    Q_INVOKABLE bool cleanHistory(int daysToKeep = 90);
    
    /// Refresca los datos desde la BD
    Q_INVOKABLE void refresh();
    
signals:
    //--------------------------------------------------------------------------
    // Se√±ales (Observer Pattern)
    //--------------------------------------------------------------------------
    
    /// Emitida cuando cambia la tasa de cambio
    /// Esta es la se√±al principal que otros m√≥dulos escuchar√°n
    void exchangeRateChanged(double newRate);
    
    /// Emitida con informaci√≥n detallada del cambio
    void rateUpdated(double newRate, double previousRate, double changePercent);
    
    /// Emitida cuando cambia el s√≠mbolo de moneda local
    void localCurrencySymbolChanged(const QString& symbol);
    
    /// Emitida cuando hay un error
    void errorOccurred(const QString& error);
    
private:
    //--------------------------------------------------------------------------
    // Constructor privado (Singleton)
    //--------------------------------------------------------------------------
    explicit CurrencyService(QObject* parent = nullptr);
    ~CurrencyService() override = default;
    
    //--------------------------------------------------------------------------
    // M√©todos privados
    //--------------------------------------------------------------------------
    
    /// Carga los datos iniciales desde la BD
    void loadFromDatabase();
    
    /// Actualiza la tendencia basada en el cambio
    void updateTrend();
    
    /// Valida una tasa de cambio
    [[nodiscard]] bool isValidRate(double rate) const;
    
    //--------------------------------------------------------------------------
    // Miembros privados
    //--------------------------------------------------------------------------
    std::unique_ptr<CurrencyRepository> m_repository;
    
    // Cache de datos
    double m_exchangeRate = Currency::Defaults::EXCHANGE_RATE_USD;
    QString m_localCurrencySymbol = "Bs.";
    QDateTime m_lastUpdate;
    double m_previousRate = 0.0;
    double m_changePercent = 0.0;
    QString m_trend = "stable";
    
    bool m_initialized = false;
};

} // namespace Vento
```

---

## üìÑ src/features/currency/CurrencyService.cpp

```cpp
//==============================================================================
// CurrencyService.cpp
// Vento - Implementaci√≥n del servicio de moneda
//==============================================================================

#include "CurrencyService.hpp"
#include "core/logger/Logger.hpp"
#include "core/utils/EventBus.hpp"

#include <QLocale>
#include <cmath>

namespace Vento {

//==============================================================================
// Singleton
//==============================================================================
CurrencyService& CurrencyService::instance() {
    static CurrencyService instance;
    return instance;
}

CurrencyService* CurrencyService::create(QQmlEngine* engine, QJSEngine* scriptEngine) {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)
    
    // Retornar instancia existente (el engine no debe tomar ownership)
    auto* instance = &CurrencyService::instance();
    QJSEngine::setObjectOwnership(instance, QJSEngine::CppOwnership);
    return instance;
}

//==============================================================================
// Constructor
//==============================================================================
CurrencyService::CurrencyService(QObject* parent)
    : QObject(parent)
    , m_repository(std::make_unique<CurrencyRepository>(this))
{
    Logger::instance().debug("CurrencyService creado", "Currency");
}

//==============================================================================
// Inicializaci√≥n
//==============================================================================
void CurrencyService::initialize() {
    if (m_initialized) {
        Logger::instance().warning("CurrencyService ya inicializado", "Currency");
        return;
    }
    
    loadFromDatabase();
    m_initialized = true;
    
    Logger::instance().info(
        QString("CurrencyService inicializado - Tasa: %1 %2")
            .arg(m_exchangeRate, 0, 'f', 2)
            .arg(m_localCurrencySymbol),
        "Currency"
    );
}

void CurrencyService::loadFromDatabase() {
    // Cargar tasa de cambio
    auto rateInfo = m_repository->getExchangeRateInfo();
    m_exchangeRate = rateInfo.rate;
    m_lastUpdate = rateInfo.lastUpdate;
    
    // Cargar s√≠mbolo de moneda
    m_localCurrencySymbol = m_repository->getLocalCurrencySymbol();
    
    // Cargar √∫ltima entrada del historial para calcular cambio
    auto lastEntry = m_repository->getLastRateEntry();
    if (lastEntry) {
        m_previousRate = lastEntry->previousRate;
        m_changePercent = lastEntry->changePercent;
        updateTrend();
    }
}

//==============================================================================
// Getters
//==============================================================================
double CurrencyService::exchangeRate() const {
    return m_exchangeRate;
}

QString CurrencyService::exchangeRateFormatted() const {
    return QString::number(m_exchangeRate, 'f', 2);
}

QString CurrencyService::localCurrencySymbol() const {
    return m_localCurrencySymbol;
}

QString CurrencyService::usdSymbol() const {
    return m_repository->getUsdSymbol();
}

QString CurrencyService::lastUpdateFormatted() const {
    if (!m_lastUpdate.isValid()) {
        return tr("Sin actualizar");
    }
    
    QDateTime now = QDateTime::currentDateTime();
    qint64 secsAgo = m_lastUpdate.secsTo(now);
    
    if (secsAgo < 60) {
        return tr("Hace un momento");
    } else if (secsAgo < 3600) {
        int mins = static_cast<int>(secsAgo / 60);
        return tr("Hace %1 min").arg(mins);
    } else if (secsAgo < 86400) {
        int hours = static_cast<int>(secsAgo / 3600);
        return tr("Hace %1 h").arg(hours);
    } else {
        return m_lastUpdate.toString("dd/MM/yyyy hh:mm");
    }
}

double CurrencyService::changePercent() const {
    return m_changePercent;
}

QString CurrencyService::trend() const {
    return m_trend;
}

//==============================================================================
// Setters
//==============================================================================
void CurrencyService::setExchangeRate(double rate) {
    if (!isValidRate(rate)) {
        emit errorOccurred(tr("Tasa de cambio inv√°lida: %1").arg(rate));
        return;
    }
    
    if (std::abs(m_exchangeRate - rate) < 0.0001) {
        return; // Sin cambio significativo
    }
    
    updateRate(rate);
}

void CurrencyService::setLocalCurrencySymbol(const QString& symbol) {
    if (symbol.isEmpty() || symbol == m_localCurrencySymbol) {
        return;
    }
    
    if (m_repository->setLocalCurrencySymbol(symbol)) {
        m_localCurrencySymbol = symbol;
        emit localCurrencySymbolChanged(symbol);
        
        Logger::instance().info(
            QString("S√≠mbolo de moneda actualizado: %1").arg(symbol),
            "Currency"
        );
    }
}

//==============================================================================
// M√©todos Q_INVOKABLE
//==============================================================================
bool CurrencyService::updateRate(double newRate) {
    return updateRateFromSource(newRate, "manual");
}

bool CurrencyService::updateRateFromSource(double newRate, const QString& source) {
    if (!isValidRate(newRate)) {
        emit errorOccurred(tr("Tasa de cambio fuera de rango permitido"));
        Logger::instance().warning(
            QString("Intento de establecer tasa inv√°lida: %1").arg(newRate),
            "Currency"
        );
        return false;
    }
    
    // Determinar fuente
    Currency::RateUpdateSource rateSource = Currency::RateUpdateSource::Manual;
    if (source == "bcv") rateSource = Currency::RateUpdateSource::BCV;
    else if (source == "dolartoday") rateSource = Currency::RateUpdateSource::DolarToday;
    else if (source == "binance") rateSource = Currency::RateUpdateSource::Binance;
    
    // Guardar tasa anterior
    double previousRate = m_exchangeRate;
    
    // Persistir en BD
    if (!m_repository->saveExchangeRate(newRate, rateSource)) {
        emit errorOccurred(tr("Error al guardar la tasa de cambio"));
        return false;
    }
    
    // Actualizar cache
    m_previousRate = previousRate;
    m_exchangeRate = newRate;
    m_lastUpdate = QDateTime::currentDateTime();
    
    // Calcular cambio porcentual
    if (m_previousRate > 0) {
        m_changePercent = ((newRate - m_previousRate) / m_previousRate) * 100.0;
    } else {
        m_changePercent = 0.0;
    }
    
    updateTrend();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PATR√ìN OBSERVER: Emitir se√±ales para notificar a otros m√≥dulos
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Se√±al simple para binding QML
    emit exchangeRateChanged(newRate);
    
    // Se√±al detallada para l√≥gica de negocio
    emit rateUpdated(newRate, previousRate, m_changePercent);
    
    // Tambi√©n publicar en el EventBus para componentes C++ que no usen se√±ales Qt
    EventBus::instance().publish(
        Events::CURRENCY_RATE_CHANGED,
        QVariant::fromValue(newRate)
    );
    
    Logger::instance().info(
        QString("üí± Tasa actualizada: %1 ‚Üí %2 (%3%4%)")
            .arg(previousRate, 0, 'f', 2)
            .arg(newRate, 0, 'f', 2)
            .arg(m_changePercent >= 0 ? "+" : "")
            .arg(m_changePercent, 0, 'f', 2),
        "Currency"
    );
    
    return true;
}

double CurrencyService::convertToLocal(double amountUsd) const {
    return amountUsd * m_exchangeRate;
}

double CurrencyService::convertToUsd(double amountLocal) const {
    if (m_exchangeRate <= 0) {
        return 0.0;
    }
    return amountLocal / m_exchangeRate;
}

QString CurrencyService::formatLocal(double amount) const {
    return formatAmount(amount, m_localCurrencySymbol, 2);
}

QString CurrencyService::formatUsd(double amount) const {
    return formatAmount(amount, usdSymbol(), 2);
}

QString CurrencyService::formatAmount(double amount, const QString& symbol, int decimals) const {
    QLocale locale(QLocale::Spanish, QLocale::Venezuela);
    QString formatted = locale.toString(amount, 'f', decimals);
    return QString("%1 %2").arg(symbol, formatted);
}

double CurrencyService::calculateSalePrice(double costUsd, double marginPercent) const {
    // Precio de venta = (Costo USD √ó Tasa) √ó (1 + Margen/100)
    double costLocal = convertToLocal(costUsd);
    double marginMultiplier = 1.0 + (marginPercent / 100.0);
    return costLocal * marginMultiplier;
}

QVariantList CurrencyService::getRateHistory(int limit) const {
    auto history = m_repository->getRateHistory(limit);
    
    QVariantList result;
    result.reserve(history.size());
    
    for (const auto& entry : history) {
        QVariantMap item;
        item["id"] = entry.id;
        item["rate"] = entry.rate;
        item["timestamp"] = entry.timestamp.toString("dd/MM/yyyy hh:mm");
        item["timestampIso"] = entry.timestamp.toString(Qt::ISODate);
        item["previousRate"] = entry.previousRate;
        item["changePercent"] = entry.changePercent;
        item["source"] = Currency::rateSourceToString(entry.source);
        item["trend"] = entry.changePercent > 0 ? "up" : 
                       (entry.changePercent < 0 ? "down" : "stable");
        result.append(item);
    }
    
    return result;
}

QVariantMap CurrencyService::getRateInfo() const {
    QVariantMap info;
    info["rate"] = m_exchangeRate;
    info["rateFormatted"] = exchangeRateFormatted();
    info["localSymbol"] = m_localCurrencySymbol;
    info["usdSymbol"] = usdSymbol();
    info["lastUpdate"] = m_lastUpdate;
    info["lastUpdateFormatted"] = lastUpdateFormatted();
    info["previousRate"] = m_previousRate;
    info["changePercent"] = m_changePercent;
    info["trend"] = m_trend;
    return info;
}

bool CurrencyService::cleanHistory(int daysToKeep) {
    return m_repository->cleanOldHistory(daysToKeep);
}

void CurrencyService::refresh() {
    loadFromDatabase();
    emit exchangeRateChanged(m_exchangeRate);
    
    Logger::instance().debug("CurrencyService refrescado", "Currency");
}

//==============================================================================
// M√©todos privados
//==============================================================================
void CurrencyService::updateTrend() {
    if (std::abs(m_changePercent) < 0.01) {
        m_trend = "stable";
    } else if (m_changePercent > 0) {
        m_trend = "up";
    } else {
        m_trend = "down";
    }
}

bool CurrencyService::isValidRate(double rate) const {
    return rate >= Currency::Defaults::MIN_EXCHANGE_RATE && 
           rate <= Currency::Defaults::MAX_EXCHANGE_RATE;
}

} // namespace Vento
```

---

## üìÑ src/features/currency/CMakeLists.txt

```cmake
#===============================================================================
# src/features/currency/CMakeLists.txt
# Vento - Feature Currency
#===============================================================================

set(CURRENCY_SOURCES
    CurrencyRepository.cpp
    CurrencyService.cpp
)

set(CURRENCY_HEADERS
    CurrencyTypes.hpp
    CurrencyModel.hpp
    CurrencyRepository.hpp
    CurrencyService.hpp
)

#===============================================================================
# Biblioteca
#===============================================================================
add_library(VentoCurrency STATIC
    ${CURRENCY_SOURCES}
    ${CURRENCY_HEADERS}
)

add_library(Vento::Currency ALIAS VentoCurrency)

#===============================================================================
# Configuraci√≥n
#===============================================================================
target_include_directories(VentoCurrency
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_CURRENT_SOURCE_DIR}/..
)

target_link_libraries(VentoCurrency
    PUBLIC
        Qt6::Core
        Qt6::Qml
        Vento::Core
)

target_compile_features(VentoCurrency PUBLIC cxx_std_20)
```

---

## üìÑ Actualizaci√≥n: src/ui/qml/Main.qml (secci√≥n Currency)

Agregar esta vista para probar el servicio:

```qml
//==============================================================================
// Secci√≥n de Currency View en Main.qml
//==============================================================================

// Agregar import al inicio del archivo:
import Vento.Currency 1.0

// Reemplazar el placeholder de Currency View con:

// Currency View
Pane {
    Material.elevation: 2
    Material.background: appColors.surface
    
    ColumnLayout {
        anchors.fill: parent
        anchors.margins: 24
        spacing: 24
        
        // Header
        RowLayout {
            Layout.fillWidth: true
            
            Label {
                text: "üí± Tipo de Cambio"
                font.pixelSize: 28
                font.weight: Font.Bold
                color: appColors.primary
            }
            
            Item { Layout.fillWidth: true }
            
            // Indicador de tendencia
            Rectangle {
                width: 100
                height: 36
                radius: 18
                color: {
                    switch(CurrencyService.trend) {
                        case "up": return "#E8F5E9"
                        case "down": return "#FFEBEE"
                        default: return "#F5F5F5"
                    }
                }
                
                RowLayout {
                    anchors.centerIn: parent
                    spacing: 4
                    
                    Label {
                        text: {
                            switch(CurrencyService.trend) {
                                case "up": return "üìà"
                                case "down": return "üìâ"
                                default: return "‚û°Ô∏è"
                            }
                        }
                        font.pixelSize: 16
                    }
                    
                    Label {
                        text: (CurrencyService.changePercent >= 0 ? "+" : "") + 
                              CurrencyService.changePercent.toFixed(2) + "%"
                        font.weight: Font.Bold
                        color: {
                            switch(CurrencyService.trend) {
                                case "up": return "#2E7D32"
                                case "down": return "#C62828"
                                default: return "#757575"
                            }
                        }
                    }
                }
            }
        }
        
        // Card de tasa actual
        Pane {
            Layout.fillWidth: true
            Layout.preferredHeight: 180
            Material.elevation: 4
            Material.background: appColors.primary
            
            ColumnLayout {
                anchors.centerIn: parent
                spacing: 12
                
                Label {
                    text: "Tasa Actual"
                    font.pixelSize: 16
                    color: "white"
                    opacity: 0.8
                    Layout.alignment: Qt.AlignHCenter
                }
                
                RowLayout {
                    Layout.alignment: Qt.AlignHCenter
                    spacing: 8
                    
                    Label {
                        text: CurrencyService.localCurrencySymbol
                        font.pixelSize: 32
                        font.weight: Font.Light
                        color: "white"
                    }
                    
                    Label {
                        text: CurrencyService.exchangeRateFormatted
                        font.pixelSize: 64
                        font.weight: Font.Bold
                        color: "white"
                    }
                }
                
                Label {
                    text: "por cada $1 USD"
                    font.pixelSize: 14
                    color: "white"
                    opacity: 0.7
                    Layout.alignment: Qt.AlignHCenter
                }
                
                Label {
                    text: "Actualizado: " + CurrencyService.lastUpdateFormatted
                    font.pixelSize: 12
                    color: "white"
                    opacity: 0.6
                    Layout.alignment: Qt.AlignHCenter
                }
            }
        }
        
        // Formulario de actualizaci√≥n
        Pane {
            Layout.fillWidth: true
            Material.elevation: 1
            
            ColumnLayout {
                anchors.fill: parent
                spacing: 16
                
                Label {
                    text: "Actualizar Tasa"
                    font.pixelSize: 18
                    font.weight: Font.DemiBold
                }
                
                RowLayout {
                    Layout.fillWidth: true
                    spacing: 16
                    
                    TextField {
                        id: newRateField
                        Layout.preferredWidth: 200
                        placeholderText: "Nueva tasa"
                        text: CurrencyService.exchangeRateFormatted
                        validator: DoubleValidator {
                            bottom: 0.01
                            top: 1000000
                            decimals: 4
                        }
                        
                        Label {
                            text: CurrencyService.localCurrencySymbol
                            anchors.right: parent.right
                            anchors.rightMargin: 12
                            anchors.verticalCenter: parent.verticalCenter
                            color: appColors.textSecondary
                        }
                    }
                    
                    ComboBox {
                        id: sourceCombo
                        Layout.preferredWidth: 180
                        model: [
                            { text: "Manual", value: "manual" },
                            { text: "BCV", value: "bcv" },
                            { text: "DolarToday", value: "dolartoday" },
                            { text: "Binance P2P", value: "binance" }
                        ]
                        textRole: "text"
                        valueRole: "value"
                    }
                    
                    Button {
                        text: "Actualizar"
                        Material.background: appColors.primary
                        Material.foreground: "white"
                        
                        onClicked: {
                            let rate = parseFloat(newRateField.text.replace(",", "."))
                            if (!isNaN(rate) && rate > 0) {
                                if (CurrencyService.updateRateFromSource(rate, sourceCombo.currentValue)) {
                                    // √âxito - el binding se actualiza autom√°ticamente
                                    updateSuccessAnimation.start()
                                }
                            }
                        }
                    }
                    
                    Item { Layout.fillWidth: true }
                }
                
                // Animaci√≥n de √©xito
                Rectangle {
                    id: successIndicator
                    Layout.fillWidth: true
                    height: 4
                    color: appColors.success
                    opacity: 0
                    radius: 2
                    
                    SequentialAnimation {
                        id: updateSuccessAnimation
                        
                        PropertyAnimation {
                            target: successIndicator
                            property: "opacity"
                            to: 1
                            duration: 200
                        }
                        
                        PauseAnimation { duration: 1000 }
                        
                        PropertyAnimation {
                            target: successIndicator
                            property: "opacity"
                            to: 0
                            duration: 300
                        }
                    }
                }
            }
        }
        
        // Conversor r√°pido
        Pane {
            Layout.fillWidth: true
            Material.elevation: 1
            
            ColumnLayout {
                anchors.fill: parent
                spacing: 16
                
                Label {
                    text: "Conversor R√°pido"
                    font.pixelSize: 18
                    font.weight: Font.DemiBold
                }
                
                RowLayout {
                    Layout.fillWidth: true
                    spacing: 24
                    
                    // USD a Local
                    ColumnLayout {
                        Layout.fillWidth: true
                        spacing: 8
                        
                        Label {
                            text: "USD ‚Üí " + CurrencyService.localCurrencySymbol
                            font.weight: Font.Medium
                        }
                        
                        RowLayout {
                            spacing: 8
                            
                            TextField {
                                id: usdInput
                                Layout.preferredWidth: 120
                                placeholderText: "0.00"
                                validator: DoubleValidator { bottom: 0; decimals: 2 }
                                
                                onTextChanged: {
                                    let value = parseFloat(text.replace(",", ".")) || 0
                                    localOutput.text = CurrencyService.convertToLocal(value).toFixed(2)
                                }
                            }
                            
                            Label { text: "‚Üí"; font.pixelSize: 20 }
                            
                            TextField {
                                id: localOutput
                                Layout.preferredWidth: 150
                                readOnly: true
                                text: "0.00"
                                
                                background: Rectangle {
                                    color: "#F5F5F5"
                                    radius: 4
                                }
                            }
                        }
                    }
                    
                    // Separador vertical
                    Rectangle {
                        Layout.fillHeight: true
                        width: 1
                        color: "#E0E0E0"
                    }
                    
                    // Local a USD
                    ColumnLayout {
                        Layout.fillWidth: true
                        spacing: 8
                        
                        Label {
                            text: CurrencyService.localCurrencySymbol + " ‚Üí USD"
                            font.weight: Font.Medium
                        }
                        
                        RowLayout {
                            spacing: 8
                            
                            TextField {
                                id: localInput
                                Layout.preferredWidth: 150
                                placeholderText: "0.00"
                                validator: DoubleValidator { bottom: 0; decimals: 2 }
                                
                                onTextChanged: {
                                    let value = parseFloat(text.replace(",", ".")) || 0
                                    usdOutput.text = CurrencyService.convertToUsd(value).toFixed(2)
                                }
                            }
                            
                            Label { text: "‚Üí"; font.pixelSize: 20 }
                            
                            TextField {
                                id: usdOutput
                                Layout.preferredWidth: 120
                                readOnly: true
                                text: "0.00"
                                
                                background: Rectangle {
                                    color: "#F5F5F5"
                                    radius: 4
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Espaciador
        Item { Layout.fillHeight: true }
    }
}

// Conexi√≥n a cambios de tasa (para actualizar otros elementos de la UI)
Connections {
    target: CurrencyService
    
    function onExchangeRateChanged(newRate) {
        console.log("Tasa actualizada:", newRate)
        // Actualizar el label del header
        exchangeRateLabel.text = CurrencyService.localCurrencySymbol + " " + 
                                 CurrencyService.exchangeRateFormatted
    }
    
    function onErrorOccurred(error) {
        console.error("Error en Currency:", error)
        // Aqu√≠ podr√≠as mostrar un snackbar o toast
    }
}
```

---

## üìä Diagrama del Flujo del Patr√≥n Observer

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     PATR√ìN OBSERVER - FLUJO DE DATOS                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       1. Usuario actualiza tasa                        ‚îÇ
‚îÇ  ‚îÇ   QML UI    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ  ‚îÇ  (Vista)    ‚îÇ                                      ‚îÇ                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                      ‚ñº                 ‚îÇ
‚îÇ         ‚îÇ                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ         ‚îÇ 5. UI se actualiza                 ‚îÇ CurrencyService ‚îÇ        ‚îÇ
‚îÇ         ‚îÇ    autom√°ticamente                 ‚îÇ   (Singleton)   ‚îÇ        ‚îÇ
‚îÇ         ‚îÇ    v√≠a bindings                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ         ‚îÇ                                             ‚îÇ                 ‚îÇ
‚îÇ         ‚îÇ                                    2. Guarda en BD            ‚îÇ
‚îÇ         ‚îÇ                                             ‚îÇ                 ‚îÇ
‚îÇ         ‚îÇ                                             ‚ñº                 ‚îÇ
‚îÇ         ‚îÇ                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ         ‚îÇ                                    ‚îÇ   Repository    ‚îÇ        ‚îÇ
‚îÇ         ‚îÇ                                    ‚îÇ   (SQLite)      ‚îÇ        ‚îÇ
‚îÇ         ‚îÇ                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ         ‚îÇ                                             ‚îÇ                 ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ                 ‚îÇ
‚îÇ   ‚îÇ                                ‚îÇ                  ‚îÇ                 ‚îÇ
‚îÇ   ‚îÇ  3. Emite se√±ales:             ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ   ‚îÇ     ‚Ä¢ exchangeRateChanged()                                         ‚îÇ
‚îÇ   ‚îÇ     ‚Ä¢ rateUpdated()                                                 ‚îÇ
‚îÇ   ‚îÇ                                                                     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                         ‚îÇ                                               ‚îÇ
‚îÇ                         ‚îÇ 4. Observadores reciben notificaci√≥n         ‚îÇ
‚îÇ                         ‚îÇ                                               ‚îÇ
‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ          ‚ñº              ‚ñº              ‚ñº               ‚ñº               ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ   ‚îÇ Inventory  ‚îÇ ‚îÇ   Sales    ‚îÇ ‚îÇ  Reporting ‚îÇ ‚îÇ  EventBus  ‚îÇ         ‚îÇ
‚îÇ   ‚îÇ  Service   ‚îÇ ‚îÇ  Service   ‚îÇ ‚îÇ   Service  ‚îÇ ‚îÇ  (C++ sub) ‚îÇ         ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
‚îÇ         ‚îÇ              ‚îÇ              ‚îÇ              ‚îÇ                  ‚îÇ
‚îÇ         ‚ñº              ‚ñº              ‚ñº              ‚ñº                  ‚îÇ
‚îÇ   Recalcula       Actualiza       Regenera      Notifica a             ‚îÇ
‚îÇ   precios de      precios en      reportes      otros m√≥dulos          ‚îÇ
‚îÇ   venta           ventas          con nueva     C++ que usen           ‚îÇ
‚îÇ                   activas         tasa          EventBus               ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ Test de Uso (ejemplo C++)

```cpp
// Ejemplo de c√≥mo otros servicios pueden escuchar cambios de tasa

#include "features/currency/CurrencyService.hpp"
#include "features/inventory/InventoryService.hpp"

// En InventoryService::initialize():
void InventoryService::initialize() {
    // Conectar al servicio de moneda para recalcular precios
    connect(
        &CurrencyService::instance(),
        &CurrencyService::exchangeRateChanged,
        this,
        &InventoryService::onExchangeRateChanged
    );
    
    // Tambi√©n con m√°s detalles
    connect(
        &CurrencyService::instance(),
        &CurrencyService::rateUpdated,
        this,
        [this](double newRate, double previousRate, double changePercent) {
            Logger::instance().info(
                QString("Inventario: Recalculando precios por cambio de tasa (%1%)")
                    .arg(changePercent, 0, 'f', 2),
                "Inventory"
            );
            recalculateAllPrices(newRate);
        }
    );
}

void InventoryService::onExchangeRateChanged(double newRate) {
    // Recalcular todos los precios de venta
    recalculateAllPrices(newRate);
    
    emit inventoryUpdated();
}
```

---

## ‚úÖ Resumen de lo Implementado

| Componente | Responsabilidad | Principio SOLID |
|------------|-----------------|-----------------|
| `CurrencyTypes.hpp` | Constantes y enums | - |
| `CurrencyModel.hpp` | Estructuras de datos | SRP |
| `CurrencyRepository` | Persistencia en BD | SRP |
| `CurrencyService` | L√≥gica de negocio + QML | Facade + Observer |
| Signals/Slots | Notificaci√≥n de cambios | OCP (extensible) |

---

¬øContinuamos con el **Feature Inventory** para que escuche los cambios de tasa y recalcule autom√°ticamente los precios de venta? üöÄ
