# Vento - Feature Inventory (Productos)

Implementaremos el sistema de inventario completo con c√°lculo autom√°tico de precios y conexi√≥n al CurrencyService.

## üìÅ Estructura del Feature

```
src/features/inventory/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ InventoryTypes.hpp       # Tipos y constantes
‚îú‚îÄ‚îÄ Product.hpp              # Estructura de producto
‚îú‚îÄ‚îÄ ProductRepository.hpp    # Capa de persistencia
‚îú‚îÄ‚îÄ ProductRepository.cpp
‚îú‚îÄ‚îÄ ProductModel.hpp         # QAbstractListModel para QML
‚îú‚îÄ‚îÄ ProductModel.cpp
‚îú‚îÄ‚îÄ InventoryService.hpp     # Servicio principal
‚îî‚îÄ‚îÄ InventoryService.cpp
```

---

## üìÑ src/features/inventory/InventoryTypes.hpp

```cpp
//==============================================================================
// InventoryTypes.hpp
// Vento - Tipos y constantes para el m√≥dulo Inventory
//==============================================================================
#pragma once

#include <QString>
#include <QObject>

namespace Vento::Inventory {

//==============================================================================
// Constantes del m√≥dulo
//==============================================================================
namespace Defaults {
    constexpr double DEFAULT_MARGIN_PERCENT = 30.0;
    constexpr double MIN_MARGIN_PERCENT = 0.0;
    constexpr double MAX_MARGIN_PERCENT = 500.0;
    constexpr int DEFAULT_MIN_STOCK_ALERT = 5;
    constexpr int DEFAULT_STOCK_QUANTITY = 0;
}

//==============================================================================
// Roles para QAbstractListModel
//==============================================================================
namespace Roles {
    enum ProductRoles {
        IdRole = Qt::UserRole + 1,
        NameRole,
        DescriptionRole,
        SkuRole,
        BarcodeRole,
        CategoryRole,
        CostUsdRole,
        CostLocalRole,
        MarginPercentRole,
        SalePriceRole,
        StockQuantityRole,
        MinStockAlertRole,
        IsActiveRole,
        CreatedAtRole,
        UpdatedAtRole,
        // Roles calculados
        ProfitAmountRole,       // Ganancia en moneda local
        ProfitPercentRole,      // Ganancia porcentual real
        IsLowStockRole,         // Si est√° por debajo del m√≠nimo
        FormattedCostUsdRole,   // Costo USD formateado
        FormattedCostLocalRole, // Costo local formateado
        FormattedSalePriceRole, // Precio de venta formateado
        StockStatusRole         // "ok", "low", "out"
    };
}

//==============================================================================
// Filtros de productos
//==============================================================================
enum class ProductFilter {
    All,
    Active,
    Inactive,
    LowStock,
    OutOfStock,
    Category
};

//==============================================================================
// Ordenamiento
//==============================================================================
enum class ProductSortField {
    Name,
    Category,
    CostUsd,
    SalePrice,
    Stock,
    CreatedAt,
    UpdatedAt
};

enum class SortOrder {
    Ascending,
    Descending
};

//==============================================================================
// Resultado de operaci√≥n
//==============================================================================
struct InventoryResult {
    bool success = false;
    QString errorMessage;
    qint64 affectedId = -1;
    int affectedCount = 0;
    
    explicit operator bool() const { return success; }
    
    static InventoryResult ok(qint64 id = -1, int count = 1) {
        return {true, {}, id, count};
    }
    
    static InventoryResult error(const QString& message) {
        return {false, message, -1, 0};
    }
};

} // namespace Vento::Inventory

// Registrar enums para uso en Qt meta-system
Q_DECLARE_METATYPE(Vento::Inventory::ProductFilter)
Q_DECLARE_METATYPE(Vento::Inventory::ProductSortField)
```

---

## üìÑ src/features/inventory/Product.hpp

```cpp
//==============================================================================
// Product.hpp
// Vento - Estructura de datos del producto
//==============================================================================
#pragma once

#include <QString>
#include <QDateTime>
#include <QJsonObject>
#include <QVariantMap>
#include <cmath>

#include "InventoryTypes.hpp"

namespace Vento {

//==============================================================================
// Product - Estructura principal del producto
//==============================================================================
struct Product {
    // Identificador
    qint64 id = 0;
    
    // Informaci√≥n b√°sica
    QString name;
    QString description;
    QString sku;
    QString barcode;
    QString category;
    
    // Precios y costos
    double costUsd = 0.0;
    double costLocal = 0.0;
    double marginPercent = Inventory::Defaults::DEFAULT_MARGIN_PERCENT;
    double salePrice = 0.0;
    
    // Inventario
    int stockQuantity = Inventory::Defaults::DEFAULT_STOCK_QUANTITY;
    int minStockAlert = Inventory::Defaults::DEFAULT_MIN_STOCK_ALERT;
    
    // Estado
    bool isActive = true;
    
    // Timestamps
    QDateTime createdAt;
    QDateTime updatedAt;
    
    //==========================================================================
    // C√°lculos
    //==========================================================================
    
    /// Calcula el precio de venta basado en costo USD, tasa y margen
    void calculateSalePrice(double exchangeRate) {
        costLocal = costUsd * exchangeRate;
        salePrice = costLocal * (1.0 + marginPercent / 100.0);
    }
    
    /// Calcula el costo local basado en costo USD y tasa
    void calculateCostLocal(double exchangeRate) {
        costLocal = costUsd * exchangeRate;
    }
    
    /// Obtiene la ganancia en moneda local
    [[nodiscard]] double profitAmount() const {
        return salePrice - costLocal;
    }
    
    /// Obtiene el porcentaje de ganancia real
    [[nodiscard]] double profitPercent() const {
        if (costLocal <= 0) return 0.0;
        return ((salePrice - costLocal) / costLocal) * 100.0;
    }
    
    /// Verifica si el stock est√° bajo
    [[nodiscard]] bool isLowStock() const {
        return stockQuantity > 0 && stockQuantity <= minStockAlert;
    }
    
    /// Verifica si est√° agotado
    [[nodiscard]] bool isOutOfStock() const {
        return stockQuantity <= 0;
    }
    
    /// Obtiene el estado del stock como string
    [[nodiscard]] QString stockStatus() const {
        if (isOutOfStock()) return "out";
        if (isLowStock()) return "low";
        return "ok";
    }
    
    //==========================================================================
    // Validaci√≥n
    //==========================================================================
    
    [[nodiscard]] bool isValid() const {
        return !name.isEmpty() && 
               costUsd >= 0 && 
               marginPercent >= 0 &&
               stockQuantity >= 0;
    }
    
    [[nodiscard]] QString validationError() const {
        if (name.isEmpty()) return "El nombre es requerido";
        if (costUsd < 0) return "El costo USD no puede ser negativo";
        if (marginPercent < 0) return "El margen no puede ser negativo";
        if (stockQuantity < 0) return "El stock no puede ser negativo";
        return {};
    }
    
    //==========================================================================
    // Serializaci√≥n
    //==========================================================================
    
    [[nodiscard]] QJsonObject toJson() const {
        return {
            {"id", id},
            {"name", name},
            {"description", description},
            {"sku", sku},
            {"barcode", barcode},
            {"category", category},
            {"costUsd", costUsd},
            {"costLocal", costLocal},
            {"marginPercent", marginPercent},
            {"salePrice", salePrice},
            {"stockQuantity", stockQuantity},
            {"minStockAlert", minStockAlert},
            {"isActive", isActive},
            {"createdAt", createdAt.toString(Qt::ISODate)},
            {"updatedAt", updatedAt.toString(Qt::ISODate)}
        };
    }
    
    [[nodiscard]] QVariantMap toVariantMap() const {
        return {
            {"id", id},
            {"name", name},
            {"description", description},
            {"sku", sku},
            {"barcode", barcode},
            {"category", category},
            {"costUsd", costUsd},
            {"costLocal", costLocal},
            {"marginPercent", marginPercent},
            {"salePrice", salePrice},
            {"stockQuantity", stockQuantity},
            {"minStockAlert", minStockAlert},
            {"isActive", isActive},
            {"profitAmount", profitAmount()},
            {"profitPercent", profitPercent()},
            {"isLowStock", isLowStock()},
            {"isOutOfStock", isOutOfStock()},
            {"stockStatus", stockStatus()},
            {"createdAt", createdAt},
            {"updatedAt", updatedAt}
        };
    }
    
    static Product fromVariantMap(const QVariantMap& map) {
        Product p;
        p.id = map.value("id").toLongLong();
        p.name = map.value("name").toString();
        p.description = map.value("description").toString();
        p.sku = map.value("sku").toString();
        p.barcode = map.value("barcode").toString();
        p.category = map.value("category").toString();
        p.costUsd = map.value("costUsd", map.value("cost_usd")).toDouble();
        p.costLocal = map.value("costLocal", map.value("cost_local")).toDouble();
        p.marginPercent = map.value("marginPercent", map.value("margin_percent")).toDouble();
        p.salePrice = map.value("salePrice", map.value("sale_price")).toDouble();
        p.stockQuantity = map.value("stockQuantity", map.value("stock_quantity")).toInt();
        p.minStockAlert = map.value("minStockAlert", map.value("min_stock_alert")).toInt();
        p.isActive = map.value("isActive", map.value("is_active", true)).toBool();
        p.createdAt = map.value("createdAt", map.value("created_at")).toDateTime();
        p.updatedAt = map.value("updatedAt", map.value("updated_at")).toDateTime();
        return p;
    }
    
    //==========================================================================
    // Comparaci√≥n
    //==========================================================================
    
    bool operator==(const Product& other) const {
        return id == other.id;
    }
    
    bool operator!=(const Product& other) const {
        return !(*this == other);
    }
};

//==============================================================================
// ProductSummary - Versi√≥n ligera para listas
//==============================================================================
struct ProductSummary {
    qint64 id;
    QString name;
    QString category;
    double salePrice;
    int stockQuantity;
    bool isLowStock;
    
    static ProductSummary fromProduct(const Product& p) {
        return {
            p.id,
            p.name,
            p.category,
            p.salePrice,
            p.stockQuantity,
            p.isLowStock()
        };
    }
};

} // namespace Vento

Q_DECLARE_METATYPE(Vento::Product)
Q_DECLARE_METATYPE(Vento::ProductSummary)
```

---

## üìÑ src/features/inventory/ProductRepository.hpp

```cpp
//==============================================================================
// ProductRepository.hpp
// Vento - Repositorio de productos (capa de persistencia)
//
// Principio: Single Responsibility - Solo operaciones de BD
//==============================================================================
#pragma once

#include <QObject>
#include <QList>
#include <optional>

#include "Product.hpp"
#include "InventoryTypes.hpp"

namespace Vento {

class ProductRepository : public QObject {
    Q_OBJECT
    
public:
    explicit ProductRepository(QObject* parent = nullptr);
    ~ProductRepository() override = default;
    
    //==========================================================================
    // CRUD Operations
    //==========================================================================
    
    /// Crea un nuevo producto
    /// @param product Producto a crear (se ignora el id)
    /// @return ID del producto creado o -1 si falla
    [[nodiscard]] qint64 create(const Product& product);
    
    /// Obtiene un producto por ID
    /// @param id ID del producto
    /// @return Producto o nullopt si no existe
    [[nodiscard]] std::optional<Product> findById(qint64 id);
    
    /// Obtiene un producto por SKU
    [[nodiscard]] std::optional<Product> findBySku(const QString& sku);
    
    /// Obtiene un producto por c√≥digo de barras
    [[nodiscard]] std::optional<Product> findByBarcode(const QString& barcode);
    
    /// Actualiza un producto existente
    /// @param product Producto con datos actualizados
    /// @return true si se actualiz√≥ correctamente
    [[nodiscard]] bool update(const Product& product);
    
    /// Elimina un producto (soft delete - marca como inactivo)
    [[nodiscard]] bool softDelete(qint64 id);
    
    /// Elimina un producto permanentemente
    [[nodiscard]] bool hardDelete(qint64 id);
    
    /// Restaura un producto eliminado (soft delete)
    [[nodiscard]] bool restore(qint64 id);
    
    //==========================================================================
    // Consultas
    //==========================================================================
    
    /// Obtiene todos los productos
    /// @param filter Filtro a aplicar
    /// @param sortField Campo de ordenamiento
    /// @param sortOrder Orden (asc/desc)
    [[nodiscard]] QList<Product> findAll(
        Inventory::ProductFilter filter = Inventory::ProductFilter::Active,
        Inventory::ProductSortField sortField = Inventory::ProductSortField::Name,
        Inventory::SortOrder sortOrder = Inventory::SortOrder::Ascending
    );
    
    /// Busca productos por nombre o descripci√≥n
    [[nodiscard]] QList<Product> search(const QString& query, int limit = 50);
    
    /// Obtiene productos por categor√≠a
    [[nodiscard]] QList<Product> findByCategory(const QString& category);
    
    /// Obtiene productos con stock bajo
    [[nodiscard]] QList<Product> findLowStock();
    
    /// Obtiene productos agotados
    [[nodiscard]] QList<Product> findOutOfStock();
    
    /// Obtiene la lista de categor√≠as √∫nicas
    [[nodiscard]] QStringList getCategories();
    
    /// Cuenta productos seg√∫n filtro
    [[nodiscard]] int count(Inventory::ProductFilter filter = Inventory::ProductFilter::All);
    
    //==========================================================================
    // Operaciones de Stock
    //==========================================================================
    
    /// Actualiza el stock de un producto
    [[nodiscard]] bool updateStock(qint64 productId, int newQuantity);
    
    /// Incrementa/decrementa el stock
    [[nodiscard]] bool adjustStock(qint64 productId, int delta);
    
    //==========================================================================
    // Operaciones de Precio (Batch)
    //==========================================================================
    
    /// Recalcula los precios de TODOS los productos con una nueva tasa
    /// @param exchangeRate Nueva tasa de cambio
    /// @return N√∫mero de productos actualizados
    [[nodiscard]] int recalculateAllPrices(double exchangeRate);
    
    /// Actualiza el precio de un producto espec√≠fico
    [[nodiscard]] bool updatePrice(qint64 productId, double costLocal, double salePrice);
    
    /// Actualiza el margen de un producto y recalcula el precio
    [[nodiscard]] bool updateMargin(qint64 productId, double marginPercent, double exchangeRate);
    
    //==========================================================================
    // Estad√≠sticas
    //==========================================================================
    
    /// Obtiene el valor total del inventario (suma de salePrice * stock)
    [[nodiscard]] double getTotalInventoryValue();
    
    /// Obtiene el costo total del inventario
    [[nodiscard]] double getTotalInventoryCost();
    
    /// Obtiene estad√≠sticas generales
    [[nodiscard]] QVariantMap getStatistics();
    
private:
    /// Construye un Product desde un row de la BD
    [[nodiscard]] Product productFromRow(const QVariantMap& row) const;
    
    /// Genera la cl√°usula WHERE seg√∫n el filtro
    [[nodiscard]] QString buildFilterClause(Inventory::ProductFilter filter) const;
    
    /// Genera la cl√°usula ORDER BY
    [[nodiscard]] QString buildOrderClause(
        Inventory::ProductSortField field, 
        Inventory::SortOrder order
    ) const;
};

} // namespace Vento
```

---

## üìÑ src/features/inventory/ProductRepository.cpp

```cpp
//==============================================================================
// ProductRepository.cpp
// Vento - Implementaci√≥n del repositorio de productos
//==============================================================================

#include "ProductRepository.hpp"
#include "core/database/DatabaseManager.hpp"
#include "core/logger/Logger.hpp"

#include <QSqlQuery>
#include <QSqlError>
#include <QDateTime>

namespace Vento {

//==============================================================================
// Constructor
//==============================================================================
ProductRepository::ProductRepository(QObject* parent) 
    : QObject(parent) 
{
    Logger::instance().debug("ProductRepository inicializado", "Inventory");
}

//==============================================================================
// CRUD - Create
//==============================================================================
qint64 ProductRepository::create(const Product& product) {
    auto& db = DatabaseManager::instance();
    
    auto result = db.execute(
        R"(
            INSERT INTO products (
                name, description, sku, barcode, category,
                cost_usd, cost_local, margin_percent, sale_price,
                stock_quantity, min_stock_alert, is_active,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 
                      datetime('now', 'localtime'), 
                      datetime('now', 'localtime'))
        )",
        {
            product.name,
            product.description,
            product.sku.isEmpty() ? QVariant(QVariant::String) : product.sku,
            product.barcode.isEmpty() ? QVariant(QVariant::String) : product.barcode,
            product.category,
            product.costUsd,
            product.costLocal,
            product.marginPercent,
            product.salePrice,
            product.stockQuantity,
            product.minStockAlert,
            product.isActive ? 1 : 0
        }
    );
    
    if (result) {
        qint64 newId = result.data.toLongLong();
        Logger::instance().info(
            QString("Producto creado: [%1] %2").arg(newId).arg(product.name),
            "Inventory"
        );
        return newId;
    }
    
    Logger::instance().error(
        QString("Error creando producto: %1").arg(result.errorMessage),
        "Inventory"
    );
    return -1;
}

//==============================================================================
// CRUD - Read
//==============================================================================
std::optional<Product> ProductRepository::findById(qint64 id) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM products WHERE id = ?",
        {id}
    );
    
    if (!rows.isEmpty()) {
        return productFromRow(rows.first());
    }
    
    return std::nullopt;
}

std::optional<Product> ProductRepository::findBySku(const QString& sku) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM products WHERE sku = ? AND is_active = 1",
        {sku}
    );
    
    if (!rows.isEmpty()) {
        return productFromRow(rows.first());
    }
    
    return std::nullopt;
}

std::optional<Product> ProductRepository::findByBarcode(const QString& barcode) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM products WHERE barcode = ? AND is_active = 1",
        {barcode}
    );
    
    if (!rows.isEmpty()) {
        return productFromRow(rows.first());
    }
    
    return std::nullopt;
}

//==============================================================================
// CRUD - Update
//==============================================================================
bool ProductRepository::update(const Product& product) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET
                name = ?,
                description = ?,
                sku = ?,
                barcode = ?,
                category = ?,
                cost_usd = ?,
                cost_local = ?,
                margin_percent = ?,
                sale_price = ?,
                stock_quantity = ?,
                min_stock_alert = ?,
                is_active = ?,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {
            product.name,
            product.description,
            product.sku.isEmpty() ? QVariant(QVariant::String) : product.sku,
            product.barcode.isEmpty() ? QVariant(QVariant::String) : product.barcode,
            product.category,
            product.costUsd,
            product.costLocal,
            product.marginPercent,
            product.salePrice,
            product.stockQuantity,
            product.minStockAlert,
            product.isActive ? 1 : 0,
            product.id
        }
    );
    
    if (result) {
        Logger::instance().debug(
            QString("Producto actualizado: [%1] %2").arg(product.id).arg(product.name),
            "Inventory"
        );
        return true;
    }
    
    Logger::instance().error(
        QString("Error actualizando producto %1: %2").arg(product.id).arg(result.errorMessage),
        "Inventory"
    );
    return false;
}

//==============================================================================
// CRUD - Delete
//==============================================================================
bool ProductRepository::softDelete(qint64 id) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                is_active = 0,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {id}
    );
    
    if (result) {
        Logger::instance().info(QString("Producto desactivado: %1").arg(id), "Inventory");
    }
    
    return result.success;
}

bool ProductRepository::hardDelete(qint64 id) {
    // Verificar que no tenga ventas asociadas
    auto checkResult = DatabaseManager::instance().executeScalar(
        "SELECT COUNT(*) FROM sale_items WHERE product_id = ?",
        {id}
    );
    
    if (checkResult && checkResult.data.toInt() > 0) {
        Logger::instance().warning(
            QString("No se puede eliminar producto %1: tiene ventas asociadas").arg(id),
            "Inventory"
        );
        return false;
    }
    
    auto result = DatabaseManager::instance().execute(
        "DELETE FROM products WHERE id = ?",
        {id}
    );
    
    if (result) {
        Logger::instance().info(QString("Producto eliminado permanentemente: %1").arg(id), "Inventory");
    }
    
    return result.success;
}

bool ProductRepository::restore(qint64 id) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                is_active = 1,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {id}
    );
    
    if (result) {
        Logger::instance().info(QString("Producto restaurado: %1").arg(id), "Inventory");
    }
    
    return result.success;
}

//==============================================================================
// Consultas
//==============================================================================
QList<Product> ProductRepository::findAll(
    Inventory::ProductFilter filter,
    Inventory::ProductSortField sortField,
    Inventory::SortOrder sortOrder
) {
    QString sql = "SELECT * FROM products";
    
    QString whereClause = buildFilterClause(filter);
    if (!whereClause.isEmpty()) {
        sql += " WHERE " + whereClause;
    }
    
    sql += " " + buildOrderClause(sortField, sortOrder);
    
    auto rows = DatabaseManager::instance().executeQuery(sql);
    
    QList<Product> products;
    products.reserve(rows.size());
    
    for (const auto& row : rows) {
        products.append(productFromRow(row));
    }
    
    return products;
}

QList<Product> ProductRepository::search(const QString& query, int limit) {
    QString searchTerm = "%" + query + "%";
    
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT * FROM products 
            WHERE is_active = 1 
              AND (name LIKE ? OR description LIKE ? OR sku LIKE ? OR barcode LIKE ?)
            ORDER BY name
            LIMIT ?
        )",
        {searchTerm, searchTerm, searchTerm, searchTerm, limit}
    );
    
    QList<Product> products;
    products.reserve(rows.size());
    
    for (const auto& row : rows) {
        products.append(productFromRow(row));
    }
    
    return products;
}

QList<Product> ProductRepository::findByCategory(const QString& category) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM products WHERE category = ? AND is_active = 1 ORDER BY name",
        {category}
    );
    
    QList<Product> products;
    for (const auto& row : rows) {
        products.append(productFromRow(row));
    }
    
    return products;
}

QList<Product> ProductRepository::findLowStock() {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT * FROM products 
            WHERE is_active = 1 
              AND stock_quantity > 0 
              AND stock_quantity <= min_stock_alert
            ORDER BY stock_quantity ASC
        )"
    );
    
    QList<Product> products;
    for (const auto& row : rows) {
        products.append(productFromRow(row));
    }
    
    return products;
}

QList<Product> ProductRepository::findOutOfStock() {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT * FROM products 
            WHERE is_active = 1 AND stock_quantity <= 0
            ORDER BY name
        )"
    );
    
    QList<Product> products;
    for (const auto& row : rows) {
        products.append(productFromRow(row));
    }
    
    return products;
}

QStringList ProductRepository::getCategories() {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT DISTINCT category FROM products 
            WHERE category IS NOT NULL AND category != '' AND is_active = 1
            ORDER BY category
        )"
    );
    
    QStringList categories;
    for (const auto& row : rows) {
        categories.append(row["category"].toString());
    }
    
    return categories;
}

int ProductRepository::count(Inventory::ProductFilter filter) {
    QString sql = "SELECT COUNT(*) FROM products";
    
    QString whereClause = buildFilterClause(filter);
    if (!whereClause.isEmpty()) {
        sql += " WHERE " + whereClause;
    }
    
    auto result = DatabaseManager::instance().executeScalar(sql);
    
    if (result) {
        return result.data.toInt();
    }
    
    return 0;
}

//==============================================================================
// Stock Operations
//==============================================================================
bool ProductRepository::updateStock(qint64 productId, int newQuantity) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                stock_quantity = ?,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {newQuantity, productId}
    );
    
    return result.success;
}

bool ProductRepository::adjustStock(qint64 productId, int delta) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                stock_quantity = MAX(0, stock_quantity + ?),
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {delta, productId}
    );
    
    return result.success;
}

//==============================================================================
// Operaciones de Precio (Batch) - CR√çTICO PARA OBSERVER
//==============================================================================
int ProductRepository::recalculateAllPrices(double exchangeRate) {
    Logger::instance().info(
        QString("Recalculando precios de todos los productos (tasa: %1)...")
            .arg(exchangeRate, 0, 'f', 2),
        "Inventory"
    );
    
    // Usar transacci√≥n para eficiencia y atomicidad
    auto& db = DatabaseManager::instance();
    
    auto result = db.executeInTransaction([exchangeRate](QSqlQuery& query) {
        // Actualizar cost_local y sale_price en una sola operaci√≥n
        // F√≥rmula: sale_price = cost_usd * exchangeRate * (1 + margin_percent/100)
        query.prepare(R"(
            UPDATE products SET
                cost_local = cost_usd * ?,
                sale_price = cost_usd * ? * (1 + margin_percent / 100.0),
                updated_at = datetime('now', 'localtime')
            WHERE is_active = 1
        )");
        
        query.addBindValue(exchangeRate);
        query.addBindValue(exchangeRate);
        
        return query.exec();
    });
    
    if (result) {
        // Obtener n√∫mero de productos actualizados
        auto countResult = db.executeScalar(
            "SELECT changes()"
        );
        
        int updated = countResult ? countResult.data.toInt() : 0;
        
        Logger::instance().info(
            QString("‚úì %1 productos actualizados con nueva tasa %2")
                .arg(updated)
                .arg(exchangeRate, 0, 'f', 2),
            "Inventory"
        );
        
        // Contar realmente los productos activos (changes() puede dar 0 si no hay cambios)
        auto activeCount = db.executeScalar("SELECT COUNT(*) FROM products WHERE is_active = 1");
        return activeCount ? activeCount.data.toInt() : updated;
    }
    
    Logger::instance().error(
        QString("Error recalculando precios: %1").arg(result.errorMessage),
        "Inventory"
    );
    
    return 0;
}

bool ProductRepository::updatePrice(qint64 productId, double costLocal, double salePrice) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                cost_local = ?,
                sale_price = ?,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {costLocal, salePrice, productId}
    );
    
    return result.success;
}

bool ProductRepository::updateMargin(qint64 productId, double marginPercent, double exchangeRate) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                margin_percent = ?,
                sale_price = cost_usd * ? * (1 + ? / 100.0),
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {marginPercent, exchangeRate, marginPercent, productId}
    );
    
    return result.success;
}

//==============================================================================
// Estad√≠sticas
//==============================================================================
double ProductRepository::getTotalInventoryValue() {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT COALESCE(SUM(sale_price * stock_quantity), 0) FROM products WHERE is_active = 1"
    );
    
    return result ? result.data.toDouble() : 0.0;
}

double ProductRepository::getTotalInventoryCost() {
    auto result = DatabaseManager::instance().executeScalar(
        "SELECT COALESCE(SUM(cost_local * stock_quantity), 0) FROM products WHERE is_active = 1"
    );
    
    return result ? result.data.toDouble() : 0.0;
}

QVariantMap ProductRepository::getStatistics() {
    auto& db = DatabaseManager::instance();
    
    QVariantMap stats;
    
    // Conteos
    stats["totalProducts"] = count(Inventory::ProductFilter::All);
    stats["activeProducts"] = count(Inventory::ProductFilter::Active);
    stats["lowStockCount"] = count(Inventory::ProductFilter::LowStock);
    stats["outOfStockCount"] = count(Inventory::ProductFilter::OutOfStock);
    
    // Valores
    stats["totalValue"] = getTotalInventoryValue();
    stats["totalCost"] = getTotalInventoryCost();
    stats["potentialProfit"] = stats["totalValue"].toDouble() - stats["totalCost"].toDouble();
    
    // Categor√≠as
    stats["categoryCount"] = getCategories().size();
    
    return stats;
}

//==============================================================================
// Helpers privados
//==============================================================================
Product ProductRepository::productFromRow(const QVariantMap& row) const {
    Product p;
    
    p.id = row["id"].toLongLong();
    p.name = row["name"].toString();
    p.description = row["description"].toString();
    p.sku = row["sku"].toString();
    p.barcode = row["barcode"].toString();
    p.category = row["category"].toString();
    p.costUsd = row["cost_usd"].toDouble();
    p.costLocal = row["cost_local"].toDouble();
    p.marginPercent = row["margin_percent"].toDouble();
    p.salePrice = row["sale_price"].toDouble();
    p.stockQuantity = row["stock_quantity"].toInt();
    p.minStockAlert = row["min_stock_alert"].toInt();
    p.isActive = row["is_active"].toBool();
    
    p.createdAt = QDateTime::fromString(
        row["created_at"].toString(), 
        "yyyy-MM-dd hh:mm:ss"
    );
    p.updatedAt = QDateTime::fromString(
        row["updated_at"].toString(), 
        "yyyy-MM-dd hh:mm:ss"
    );
    
    return p;
}

QString ProductRepository::buildFilterClause(Inventory::ProductFilter filter) const {
    switch (filter) {
        case Inventory::ProductFilter::Active:
            return "is_active = 1";
        case Inventory::ProductFilter::Inactive:
            return "is_active = 0";
        case Inventory::ProductFilter::LowStock:
            return "is_active = 1 AND stock_quantity > 0 AND stock_quantity <= min_stock_alert";
        case Inventory::ProductFilter::OutOfStock:
            return "is_active = 1 AND stock_quantity <= 0";
        case Inventory::ProductFilter::All:
        default:
            return {};
    }
}

QString ProductRepository::buildOrderClause(
    Inventory::ProductSortField field, 
    Inventory::SortOrder order
) const {
    QString column;
    
    switch (field) {
        case Inventory::ProductSortField::Name:
            column = "name";
            break;
        case Inventory::ProductSortField::Category:
            column = "category";
            break;
        case Inventory::ProductSortField::CostUsd:
            column = "cost_usd";
            break;
        case Inventory::ProductSortField::SalePrice:
            column = "sale_price";
            break;
        case Inventory::ProductSortField::Stock:
            column = "stock_quantity";
            break;
        case Inventory::ProductSortField::CreatedAt:
            column = "created_at";
            break;
        case Inventory::ProductSortField::UpdatedAt:
            column = "updated_at";
            break;
        default:
            column = "name";
    }
    
    QString direction = (order == Inventory::SortOrder::Descending) ? "DESC" : "ASC";
    
    return QString("ORDER BY %1 %2").arg(column, direction);
}

} // namespace Vento
```

---

## üìÑ src/features/inventory/ProductModel.hpp

```cpp
//==============================================================================
// ProductModel.hpp
// Vento - Modelo de productos para QML (QAbstractListModel)
//
// Este modelo proporciona una interfaz eficiente entre la BD y la UI QML
//==============================================================================
#pragma once

#include <QAbstractListModel>
#include <QList>
#include <QHash>
#include <memory>

#include "Product.hpp"
#include "InventoryTypes.hpp"
#include "ProductRepository.hpp"

namespace Vento {

class ProductModel : public QAbstractListModel {
    Q_OBJECT
    
    //==========================================================================
    // Propiedades QML
    //==========================================================================
    
    Q_PROPERTY(int count READ count NOTIFY countChanged)
    Q_PROPERTY(bool loading READ isLoading NOTIFY loadingChanged)
    Q_PROPERTY(QString filterText READ filterText WRITE setFilterText NOTIFY filterTextChanged)
    Q_PROPERTY(QString categoryFilter READ categoryFilter WRITE setCategoryFilter NOTIFY categoryFilterChanged)
    Q_PROPERTY(int totalProducts READ totalProducts NOTIFY countChanged)
    Q_PROPERTY(int lowStockCount READ lowStockCount NOTIFY dataChanged)
    Q_PROPERTY(int outOfStockCount READ outOfStockCount NOTIFY dataChanged)
    
public:
    //==========================================================================
    // Constructor
    //==========================================================================
    explicit ProductModel(QObject* parent = nullptr);
    ~ProductModel() override = default;
    
    //==========================================================================
    // QAbstractListModel Interface
    //==========================================================================
    
    [[nodiscard]] int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    
    [[nodiscard]] QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    
    [[nodiscard]] bool setData(const QModelIndex& index, const QVariant& value, int role = Qt::EditRole) override;
    
    [[nodiscard]] Qt::ItemFlags flags(const QModelIndex& index) const override;
    
    [[nodiscard]] QHash<int, QByteArray> roleNames() const override;
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    
    [[nodiscard]] int count() const;
    [[nodiscard]] bool isLoading() const;
    [[nodiscard]] QString filterText() const;
    [[nodiscard]] QString categoryFilter() const;
    [[nodiscard]] int totalProducts() const;
    [[nodiscard]] int lowStockCount() const;
    [[nodiscard]] int outOfStockCount() const;
    
    void setFilterText(const QString& text);
    void setCategoryFilter(const QString& category);
    
    //==========================================================================
    // M√©todos Q_INVOKABLE (accesibles desde QML)
    //==========================================================================
    
    /// Carga/recarga todos los productos
    Q_INVOKABLE void load();
    
    /// Obtiene un producto por √≠ndice
    Q_INVOKABLE QVariantMap get(int index) const;
    
    /// Obtiene un producto por ID
    Q_INVOKABLE QVariantMap getById(qint64 id) const;
    
    /// A√±ade un nuevo producto
    /// @return ID del producto creado o -1 si falla
    Q_INVOKABLE qint64 addProduct(const QVariantMap& productData);
    
    /// Actualiza un producto existente
    Q_INVOKABLE bool updateProduct(qint64 id, const QVariantMap& productData);
    
    /// Elimina un producto (soft delete)
    Q_INVOKABLE bool deleteProduct(qint64 id);
    
    /// Elimina un producto permanentemente
    Q_INVOKABLE bool deleteProductPermanently(qint64 id);
    
    /// Restaura un producto eliminado
    Q_INVOKABLE bool restoreProduct(qint64 id);
    
    /// Actualiza el stock de un producto
    Q_INVOKABLE bool updateStock(qint64 id, int quantity);
    
    /// Ajusta el stock (incrementa/decrementa)
    Q_INVOKABLE bool adjustStock(qint64 id, int delta);
    
    /// Busca productos
    Q_INVOKABLE void search(const QString& query);
    
    /// Limpia los filtros
    Q_INVOKABLE void clearFilters();
    
    /// Ordena por campo
    Q_INVOKABLE void sortBy(const QString& field, bool ascending = true);
    
    /// Obtiene la lista de categor√≠as
    Q_INVOKABLE QStringList getCategories() const;
    
    /// Obtiene el √≠ndice de un producto por ID
    Q_INVOKABLE int indexOfId(qint64 id) const;
    
    //==========================================================================
    // M√©todos para el Observer (llamados desde InventoryService)
    //==========================================================================
    
    /// Recalcula todos los precios con una nueva tasa
    void recalculatePrices(double exchangeRate);
    
    /// Refresca un producto espec√≠fico
    void refreshProduct(qint64 id);
    
    /// Establece el repositorio (inyecci√≥n de dependencia)
    void setRepository(ProductRepository* repo);
    
signals:
    void countChanged();
    void loadingChanged();
    void filterTextChanged();
    void categoryFilterChanged();
    void dataChanged();
    
    /// Emitida cuando se a√±ade un producto
    void productAdded(qint64 id);
    
    /// Emitida cuando se actualiza un producto
    void productUpdated(qint64 id);
    
    /// Emitida cuando se elimina un producto
    void productDeleted(qint64 id);
    
    /// Emitida cuando se recalculan los precios
    void pricesRecalculated(int count);
    
    /// Emitida cuando hay un error
    void errorOccurred(const QString& error);
    
private:
    //==========================================================================
    // Helpers
    //==========================================================================
    
    /// Encuentra el √≠ndice de un producto por ID
    [[nodiscard]] int findIndexById(qint64 id) const;
    
    /// Aplica los filtros actuales y recarga
    void applyFilters();
    
    /// Notifica cambio en un rango
    void notifyDataChanged(int first, int last);
    
    //==========================================================================
    // Miembros
    //==========================================================================
    QList<Product> m_products;
    ProductRepository* m_repository = nullptr;
    bool m_ownsRepository = false;
    
    // Estado
    bool m_loading = false;
    QString m_filterText;
    QString m_categoryFilter;
    Inventory::ProductSortField m_sortField = Inventory::ProductSortField::Name;
    Inventory::SortOrder m_sortOrder = Inventory::SortOrder::Ascending;
    
    // Cache de conteos
    mutable int m_cachedLowStock = -1;
    mutable int m_cachedOutOfStock = -1;
};

} // namespace Vento
```

---

## üìÑ src/features/inventory/ProductModel.cpp

```cpp
//==============================================================================
// ProductModel.cpp
// Vento - Implementaci√≥n del modelo de productos
//==============================================================================

#include "ProductModel.hpp"
#include "core/logger/Logger.hpp"
#include "features/currency/CurrencyService.hpp"

#include <algorithm>

namespace Vento {

//==============================================================================
// Constructor
//==============================================================================
ProductModel::ProductModel(QObject* parent)
    : QAbstractListModel(parent)
    , m_repository(new ProductRepository(this))
    , m_ownsRepository(true)
{
    Logger::instance().debug("ProductModel creado", "Inventory");
}

//==============================================================================
// QAbstractListModel Interface
//==============================================================================
int ProductModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return static_cast<int>(m_products.size());
}

QVariant ProductModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() < 0 || index.row() >= m_products.size()) {
        return {};
    }
    
    const Product& product = m_products.at(index.row());
    auto& currency = CurrencyService::instance();
    
    using namespace Inventory::Roles;
    
    switch (role) {
        case IdRole:
            return product.id;
        case NameRole:
            return product.name;
        case DescriptionRole:
            return product.description;
        case SkuRole:
            return product.sku;
        case BarcodeRole:
            return product.barcode;
        case CategoryRole:
            return product.category;
        case CostUsdRole:
            return product.costUsd;
        case CostLocalRole:
            return product.costLocal;
        case MarginPercentRole:
            return product.marginPercent;
        case SalePriceRole:
            return product.salePrice;
        case StockQuantityRole:
            return product.stockQuantity;
        case MinStockAlertRole:
            return product.minStockAlert;
        case IsActiveRole:
            return product.isActive;
        case CreatedAtRole:
            return product.createdAt;
        case UpdatedAtRole:
            return product.updatedAt;
            
        // Roles calculados
        case ProfitAmountRole:
            return product.profitAmount();
        case ProfitPercentRole:
            return product.profitPercent();
        case IsLowStockRole:
            return product.isLowStock();
        case StockStatusRole:
            return product.stockStatus();
            
        // Formateados
        case FormattedCostUsdRole:
            return currency.formatUsd(product.costUsd);
        case FormattedCostLocalRole:
            return currency.formatLocal(product.costLocal);
        case FormattedSalePriceRole:
            return currency.formatLocal(product.salePrice);
            
        default:
            return {};
    }
}

bool ProductModel::setData(const QModelIndex& index, const QVariant& value, int role) {
    if (!index.isValid() || index.row() < 0 || index.row() >= m_products.size()) {
        return false;
    }
    
    Product& product = m_products[index.row()];
    bool changed = false;
    
    using namespace Inventory::Roles;
    
    switch (role) {
        case NameRole:
            if (product.name != value.toString()) {
                product.name = value.toString();
                changed = true;
            }
            break;
        case StockQuantityRole:
            if (product.stockQuantity != value.toInt()) {
                product.stockQuantity = value.toInt();
                changed = true;
            }
            break;
        case MarginPercentRole:
            if (qAbs(product.marginPercent - value.toDouble()) > 0.001) {
                product.marginPercent = value.toDouble();
                product.calculateSalePrice(CurrencyService::instance().exchangeRate());
                changed = true;
            }
            break;
        // A√±adir m√°s casos seg√∫n necesidad
        default:
            return false;
    }
    
    if (changed) {
        // Persistir cambio en BD
        if (m_repository->update(product)) {
            emit dataChanged(index, index, {role});
            return true;
        }
    }
    
    return false;
}

Qt::ItemFlags ProductModel::flags(const QModelIndex& index) const {
    if (!index.isValid()) {
        return Qt::NoItemFlags;
    }
    return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
}

QHash<int, QByteArray> ProductModel::roleNames() const {
    using namespace Inventory::Roles;
    
    return {
        {IdRole, "id"},
        {NameRole, "name"},
        {DescriptionRole, "description"},
        {SkuRole, "sku"},
        {BarcodeRole, "barcode"},
        {CategoryRole, "category"},
        {CostUsdRole, "costUsd"},
        {CostLocalRole, "costLocal"},
        {MarginPercentRole, "marginPercent"},
        {SalePriceRole, "salePrice"},
        {StockQuantityRole, "stockQuantity"},
        {MinStockAlertRole, "minStockAlert"},
        {IsActiveRole, "isActive"},
        {CreatedAtRole, "createdAt"},
        {UpdatedAtRole, "updatedAt"},
        {ProfitAmountRole, "profitAmount"},
        {ProfitPercentRole, "profitPercent"},
        {IsLowStockRole, "isLowStock"},
        {FormattedCostUsdRole, "formattedCostUsd"},
        {FormattedCostLocalRole, "formattedCostLocal"},
        {FormattedSalePriceRole, "formattedSalePrice"},
        {StockStatusRole, "stockStatus"}
    };
}

//==============================================================================
// Propiedades
//==============================================================================
int ProductModel::count() const {
    return static_cast<int>(m_products.size());
}

bool ProductModel::isLoading() const {
    return m_loading;
}

QString ProductModel::filterText() const {
    return m_filterText;
}

QString ProductModel::categoryFilter() const {
    return m_categoryFilter;
}

int ProductModel::totalProducts() const {
    return m_repository ? m_repository->count(Inventory::ProductFilter::Active) : 0;
}

int ProductModel::lowStockCount() const {
    if (m_cachedLowStock < 0 && m_repository) {
        m_cachedLowStock = m_repository->count(Inventory::ProductFilter::LowStock);
    }
    return m_cachedLowStock;
}

int ProductModel::outOfStockCount() const {
    if (m_cachedOutOfStock < 0 && m_repository) {
        m_cachedOutOfStock = m_repository->count(Inventory::ProductFilter::OutOfStock);
    }
    return m_cachedOutOfStock;
}

void ProductModel::setFilterText(const QString& text) {
    if (m_filterText != text) {
        m_filterText = text;
        emit filterTextChanged();
        applyFilters();
    }
}

void ProductModel::setCategoryFilter(const QString& category) {
    if (m_categoryFilter != category) {
        m_categoryFilter = category;
        emit categoryFilterChanged();
        applyFilters();
    }
}

//==============================================================================
// M√©todos Q_INVOKABLE
//==============================================================================
void ProductModel::load() {
    if (!m_repository) return;
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    
    m_products = m_repository->findAll(
        Inventory::ProductFilter::Active,
        m_sortField,
        m_sortOrder
    );
    
    // Invalidar cache
    m_cachedLowStock = -1;
    m_cachedOutOfStock = -1;
    
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
    emit dataChanged();
    
    Logger::instance().debug(
        QString("ProductModel: %1 productos cargados").arg(m_products.size()),
        "Inventory"
    );
}

QVariantMap ProductModel::get(int index) const {
    if (index < 0 || index >= m_products.size()) {
        return {};
    }
    return m_products.at(index).toVariantMap();
}

QVariantMap ProductModel::getById(qint64 id) const {
    int index = findIndexById(id);
    if (index >= 0) {
        return m_products.at(index).toVariantMap();
    }
    
    // Buscar en BD si no est√° en el modelo
    if (m_repository) {
        auto product = m_repository->findById(id);
        if (product) {
            return product->toVariantMap();
        }
    }
    
    return {};
}

qint64 ProductModel::addProduct(const QVariantMap& productData) {
    if (!m_repository) return -1;
    
    // Crear producto desde datos
    Product product = Product::fromVariantMap(productData);
    
    // Validar
    if (!product.isValid()) {
        emit errorOccurred(product.validationError());
        return -1;
    }
    
    // Calcular precios
    double rate = CurrencyService::instance().exchangeRate();
    product.calculateSalePrice(rate);
    
    // Persistir
    qint64 newId = m_repository->create(product);
    
    if (newId > 0) {
        product.id = newId;
        product.createdAt = QDateTime::currentDateTime();
        product.updatedAt = product.createdAt;
        
        // A√±adir al modelo
        int newIndex = m_products.size();
        beginInsertRows(QModelIndex(), newIndex, newIndex);
        m_products.append(product);
        endInsertRows();
        
        // Invalidar cache
        m_cachedLowStock = -1;
        m_cachedOutOfStock = -1;
        
        emit countChanged();
        emit productAdded(newId);
        
        Logger::instance().info(
            QString("Producto a√±adido: [%1] %2 - Precio: %3")
                .arg(newId)
                .arg(product.name)
                .arg(product.salePrice, 0, 'f', 2),
            "Inventory"
        );
    }
    
    return newId;
}

bool ProductModel::updateProduct(qint64 id, const QVariantMap& productData) {
    if (!m_repository) return false;
    
    int index = findIndexById(id);
    if (index < 0) {
        emit errorOccurred(tr("Producto no encontrado"));
        return false;
    }
    
    Product& product = m_products[index];
    
    // Actualizar campos
    if (productData.contains("name")) 
        product.name = productData["name"].toString();
    if (productData.contains("description")) 
        product.description = productData["description"].toString();
    if (productData.contains("sku")) 
        product.sku = productData["sku"].toString();
    if (productData.contains("barcode")) 
        product.barcode = productData["barcode"].toString();
    if (productData.contains("category")) 
        product.category = productData["category"].toString();
    if (productData.contains("costUsd")) 
        product.costUsd = productData["costUsd"].toDouble();
    if (productData.contains("marginPercent")) 
        product.marginPercent = productData["marginPercent"].toDouble();
    if (productData.contains("stockQuantity")) 
        product.stockQuantity = productData["stockQuantity"].toInt();
    if (productData.contains("minStockAlert")) 
        product.minStockAlert = productData["minStockAlert"].toInt();
    
    // Recalcular precio
    double rate = CurrencyService::instance().exchangeRate();
    product.calculateSalePrice(rate);
    product.updatedAt = QDateTime::currentDateTime();
    
    // Validar
    if (!product.isValid()) {
        emit errorOccurred(product.validationError());
        return false;
    }
    
    // Persistir
    if (m_repository->update(product)) {
        QModelIndex modelIndex = createIndex(index, 0);
        emit dataChanged(modelIndex, modelIndex);
        emit productUpdated(id);
        
        // Invalidar cache
        m_cachedLowStock = -1;
        m_cachedOutOfStock = -1;
        
        Logger::instance().info(
            QString("Producto actualizado: [%1] %2").arg(id).arg(product.name),
            "Inventory"
        );
        
        return true;
    }
    
    return false;
}

bool ProductModel::deleteProduct(qint64 id) {
    if (!m_repository) return false;
    
    int index = findIndexById(id);
    if (index < 0) return false;
    
    if (m_repository->softDelete(id)) {
        beginRemoveRows(QModelIndex(), index, index);
        m_products.removeAt(index);
        endRemoveRows();
        
        m_cachedLowStock = -1;
        m_cachedOutOfStock = -1;
        
        emit countChanged();
        emit productDeleted(id);
        
        return true;
    }
    
    return false;
}

bool ProductModel::deleteProductPermanently(qint64 id) {
    if (!m_repository) return false;
    
    int index = findIndexById(id);
    
    if (m_repository->hardDelete(id)) {
        if (index >= 0) {
            beginRemoveRows(QModelIndex(), index, index);
            m_products.removeAt(index);
            endRemoveRows();
            emit countChanged();
        }
        
        emit productDeleted(id);
        return true;
    }
    
    return false;
}

bool ProductModel::restoreProduct(qint64 id) {
    if (!m_repository) return false;
    
    if (m_repository->restore(id)) {
        // Recargar para incluir el producto restaurado
        load();
        return true;
    }
    
    return false;
}

bool ProductModel::updateStock(qint64 id, int quantity) {
    if (!m_repository) return false;
    
    if (m_repository->updateStock(id, quantity)) {
        int index = findIndexById(id);
        if (index >= 0) {
            m_products[index].stockQuantity = quantity;
            QModelIndex modelIndex = createIndex(index, 0);
            emit dataChanged(modelIndex, modelIndex, {Inventory::Roles::StockQuantityRole});
        }
        
        m_cachedLowStock = -1;
        m_cachedOutOfStock = -1;
        emit dataChanged();
        
        return true;
    }
    
    return false;
}

bool ProductModel::adjustStock(qint64 id, int delta) {
    if (!m_repository) return false;
    
    if (m_repository->adjustStock(id, delta)) {
        int index = findIndexById(id);
        if (index >= 0) {
            m_products[index].stockQuantity = std::max(0, m_products[index].stockQuantity + delta);
            QModelIndex modelIndex = createIndex(index, 0);
            emit dataChanged(modelIndex, modelIndex, {Inventory::Roles::StockQuantityRole});
        }
        
        m_cachedLowStock = -1;
        m_cachedOutOfStock = -1;
        
        return true;
    }
    
    return false;
}

void ProductModel::search(const QString& query) {
    if (!m_repository) return;
    
    if (query.isEmpty()) {
        load();
        return;
    }
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    m_products = m_repository->search(query);
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
}

void ProductModel::clearFilters() {
    m_filterText.clear();
    m_categoryFilter.clear();
    emit filterTextChanged();
    emit categoryFilterChanged();
    load();
}

void ProductModel::sortBy(const QString& field, bool ascending) {
    if (field == "name") m_sortField = Inventory::ProductSortField::Name;
    else if (field == "category") m_sortField = Inventory::ProductSortField::Category;
    else if (field == "price") m_sortField = Inventory::ProductSortField::SalePrice;
    else if (field == "stock") m_sortField = Inventory::ProductSortField::Stock;
    else if (field == "created") m_sortField = Inventory::ProductSortField::CreatedAt;
    
    m_sortOrder = ascending ? Inventory::SortOrder::Ascending : Inventory::SortOrder::Descending;
    
    load();
}

QStringList ProductModel::getCategories() const {
    if (m_repository) {
        return m_repository->getCategories();
    }
    return {};
}

int ProductModel::indexOfId(qint64 id) const {
    return findIndexById(id);
}

//==============================================================================
// M√©todos Observer - CR√çTICO
//==============================================================================
void ProductModel::recalculatePrices(double exchangeRate) {
    Logger::instance().info(
        QString("ProductModel: Recalculando precios con tasa %1").arg(exchangeRate, 0, 'f', 2),
        "Inventory"
    );
    
    // 1. Actualizar en la BD (batch, eficiente)
    int updatedCount = 0;
    if (m_repository) {
        updatedCount = m_repository->recalculateAllPrices(exchangeRate);
    }
    
    // 2. Actualizar el modelo en memoria
    for (int i = 0; i < m_products.size(); ++i) {
        m_products[i].calculateSalePrice(exchangeRate);
    }
    
    // 3. Notificar a la UI que todos los datos cambiaron
    if (!m_products.isEmpty()) {
        emit dataChanged(
            createIndex(0, 0),
            createIndex(m_products.size() - 1, 0),
            {
                Inventory::Roles::CostLocalRole,
                Inventory::Roles::SalePriceRole,
                Inventory::Roles::ProfitAmountRole,
                Inventory::Roles::FormattedCostLocalRole,
                Inventory::Roles::FormattedSalePriceRole
            }
        );
    }
    
    emit pricesRecalculated(updatedCount);
    
    Logger::instance().info(
        QString("‚úì %1 productos actualizados en modelo").arg(m_products.size()),
        "Inventory"
    );
}

void ProductModel::refreshProduct(qint64 id) {
    if (!m_repository) return;
    
    auto product = m_repository->findById(id);
    if (!product) return;
    
    int index = findIndexById(id);
    if (index >= 0) {
        m_products[index] = *product;
        QModelIndex modelIndex = createIndex(index, 0);
        emit dataChanged(modelIndex, modelIndex);
    }
}

void ProductModel::setRepository(ProductRepository* repo) {
    if (m_ownsRepository && m_repository) {
        delete m_repository;
    }
    m_repository = repo;
    m_ownsRepository = false;
}

//==============================================================================
// Helpers Privados
//==============================================================================
int ProductModel::findIndexById(qint64 id) const {
    for (int i = 0; i < m_products.size(); ++i) {
        if (m_products[i].id == id) {
            return i;
        }
    }
    return -1;
}

void ProductModel::applyFilters() {
    if (!m_repository) return;
    
    if (m_filterText.isEmpty() && m_categoryFilter.isEmpty()) {
        load();
        return;
    }
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    
    if (!m_filterText.isEmpty()) {
        m_products = m_repository->search(m_filterText);
    } else if (!m_categoryFilter.isEmpty()) {
        m_products = m_repository->findByCategory(m_categoryFilter);
    }
    
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
}

void ProductModel::notifyDataChanged(int first, int last) {
    emit dataChanged(
        createIndex(first, 0),
        createIndex(last, 0)
    );
}

} // namespace Vento
```

---

## üìÑ src/features/inventory/InventoryService.hpp

```cpp
//==============================================================================
// InventoryService.hpp
// Vento - Servicio principal de inventario expuesto a QML
//
// Este servicio:
// - Act√∫a como fachada del m√≥dulo Inventory
// - Escucha cambios de CurrencyService (Observer)
// - Proporciona el ProductModel a QML
//==============================================================================
#pragma once

#include <QObject>
#include <QQmlEngine>
#include <memory>

#include "Product.hpp"
#include "ProductModel.hpp"
#include "ProductRepository.hpp"
#include "InventoryTypes.hpp"

namespace Vento {

// Forward declaration
class CurrencyService;

class InventoryService : public QObject {
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    
    //==========================================================================
    // Propiedades QML
    //==========================================================================
    
    /// Modelo de productos para ListView
    Q_PROPERTY(ProductModel* products READ products CONSTANT)
    
    /// Estad√≠sticas del inventario
    Q_PROPERTY(QVariantMap statistics READ statistics NOTIFY statisticsChanged)
    
    /// Tasa de cambio actual (delegada a CurrencyService)
    Q_PROPERTY(double currentExchangeRate READ currentExchangeRate NOTIFY exchangeRateUpdated)
    
    /// Lista de categor√≠as
    Q_PROPERTY(QStringList categories READ categories NOTIFY categoriesChanged)
    
    /// N√∫mero total de productos activos
    Q_PROPERTY(int totalProducts READ totalProducts NOTIFY statisticsChanged)
    
    /// Productos con bajo stock
    Q_PROPERTY(int lowStockCount READ lowStockCount NOTIFY statisticsChanged)
    
    /// Productos agotados
    Q_PROPERTY(int outOfStockCount READ outOfStockCount NOTIFY statisticsChanged)
    
public:
    //==========================================================================
    // Singleton
    //==========================================================================
    static InventoryService& instance();
    static InventoryService* create(QQmlEngine* engine, QJSEngine* scriptEngine);
    
    InventoryService(const InventoryService&) = delete;
    InventoryService& operator=(const InventoryService&) = delete;
    
    //==========================================================================
    // Inicializaci√≥n
    //==========================================================================
    
    /// Inicializa el servicio y conecta con CurrencyService
    void initialize();
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    
    [[nodiscard]] ProductModel* products();
    [[nodiscard]] QVariantMap statistics() const;
    [[nodiscard]] double currentExchangeRate() const;
    [[nodiscard]] QStringList categories() const;
    [[nodiscard]] int totalProducts() const;
    [[nodiscard]] int lowStockCount() const;
    [[nodiscard]] int outOfStockCount() const;
    
    //==========================================================================
    // M√©todos Q_INVOKABLE
    //==========================================================================
    
    /// A√±ade un nuevo producto
    Q_INVOKABLE qint64 addProduct(
        const QString& name,
        const QString& description,
        const QString& category,
        double costUsd,
        double marginPercent,
        int stockQuantity = 0,
        const QString& sku = {},
        const QString& barcode = {}
    );
    
    /// A√±ade un producto desde QVariantMap
    Q_INVOKABLE qint64 addProductFromMap(const QVariantMap& data);
    
    /// Actualiza un producto
    Q_INVOKABLE bool updateProduct(qint64 id, const QVariantMap& data);
    
    /// Elimina un producto
    Q_INVOKABLE bool deleteProduct(qint64 id);
    
    /// Obtiene un producto por ID
    Q_INVOKABLE QVariantMap getProduct(qint64 id) const;
    
    /// Busca producto por c√≥digo de barras
    Q_INVOKABLE QVariantMap findByBarcode(const QString& barcode) const;
    
    /// Busca producto por SKU
    Q_INVOKABLE QVariantMap findBySku(const QString& sku) const;
    
    /// Actualiza el stock
    Q_INVOKABLE bool updateStock(qint64 productId, int newQuantity);
    
    /// Ajusta el stock (incrementar/decrementar)
    Q_INVOKABLE bool adjustStock(qint64 productId, int delta);
    
    /// Calcula el precio de venta para un producto
    Q_INVOKABLE double calculateSalePrice(double costUsd, double marginPercent) const;
    
    /// Formatea un precio para mostrar
    Q_INVOKABLE QString formatPrice(double amount) const;
    
    /// Refresca todos los datos
    Q_INVOKABLE void refresh();
    
    /// Obtiene productos con bajo stock
    Q_INVOKABLE QVariantList getLowStockProducts() const;
    
    /// Obtiene productos agotados
    Q_INVOKABLE QVariantList getOutOfStockProducts() const;
    
    /// Exporta el inventario (retorna datos para exportar)
    Q_INVOKABLE QVariantList exportInventory() const;
    
signals:
    void statisticsChanged();
    void categoriesChanged();
    void exchangeRateUpdated(double newRate);
    
    /// Emitida cuando un producto es a√±adido
    void productAdded(qint64 productId, const QString& name);
    
    /// Emitida cuando un producto es actualizado
    void productUpdated(qint64 productId);
    
    /// Emitida cuando un producto es eliminado
    void productDeleted(qint64 productId);
    
    /// Emitida cuando los precios son recalculados
    void pricesRecalculated(int productCount, double newRate);
    
    /// Emitida cuando hay alertas de stock bajo
    void lowStockAlert(int count);
    
    /// Emitida cuando hay un error
    void errorOccurred(const QString& error);
    
private slots:
    //==========================================================================
    // Slots para Observer Pattern
    //==========================================================================
    
    /// Llamado cuando cambia la tasa de cambio
    void onExchangeRateChanged(double newRate);
    
    /// Llamado con informaci√≥n detallada del cambio de tasa
    void onRateUpdated(double newRate, double previousRate, double changePercent);
    
private:
    //==========================================================================
    // Constructor privado (Singleton)
    //==========================================================================
    explicit InventoryService(QObject* parent = nullptr);
    ~InventoryService() override = default;
    
    //==========================================================================
    // Helpers
    //==========================================================================
    void connectToCurrencyService();
    void updateStatistics();
    void checkLowStockAlerts();
    
    //==========================================================================
    // Miembros
    //==========================================================================
    std::unique_ptr<ProductModel> m_productModel;
    std::unique_ptr<ProductRepository> m_repository;
    
    mutable QVariantMap m_cachedStatistics;
    mutable bool m_statisticsDirty = true;
    
    bool m_initialized = false;
};

} // namespace Vento
```

---

## üìÑ src/features/inventory/InventoryService.cpp

```cpp
//==============================================================================
// InventoryService.cpp
// Vento - Implementaci√≥n del servicio de inventario
//==============================================================================

#include "InventoryService.hpp"
#include "features/currency/CurrencyService.hpp"
#include "core/logger/Logger.hpp"
#include "core/utils/EventBus.hpp"

namespace Vento {

//==============================================================================
// Singleton
//==============================================================================
InventoryService& InventoryService::instance() {
    static InventoryService instance;
    return instance;
}

InventoryService* InventoryService::create(QQmlEngine* engine, QJSEngine* scriptEngine) {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)
    
    auto* instance = &InventoryService::instance();
    QJSEngine::setObjectOwnership(instance, QJSEngine::CppOwnership);
    return instance;
}

//==============================================================================
// Constructor
//==============================================================================
InventoryService::InventoryService(QObject* parent)
    : QObject(parent)
    , m_productModel(std::make_unique<ProductModel>(this))
    , m_repository(std::make_unique<ProductRepository>(this))
{
    // Conectar se√±ales del modelo
    connect(m_productModel.get(), &ProductModel::productAdded,
            this, [this](qint64 id) {
                m_statisticsDirty = true;
                emit statisticsChanged();
                
                auto product = m_repository->findById(id);
                if (product) {
                    emit productAdded(id, product->name);
                }
            });
    
    connect(m_productModel.get(), &ProductModel::productUpdated,
            this, [this](qint64 id) {
                m_statisticsDirty = true;
                emit productUpdated(id);
            });
    
    connect(m_productModel.get(), &ProductModel::productDeleted,
            this, [this](qint64 id) {
                m_statisticsDirty = true;
                emit statisticsChanged();
                emit productDeleted(id);
            });
    
    connect(m_productModel.get(), &ProductModel::pricesRecalculated,
            this, [this](int count) {
                m_statisticsDirty = true;
                emit statisticsChanged();
            });
    
    Logger::instance().debug("InventoryService creado", "Inventory");
}

//==============================================================================
// Inicializaci√≥n
//==============================================================================
void InventoryService::initialize() {
    if (m_initialized) {
        Logger::instance().warning("InventoryService ya inicializado", "Inventory");
        return;
    }
    
    Logger::instance().info("Inicializando InventoryService...", "Inventory");
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONEXI√ìN CON CURRENCY SERVICE (OBSERVER PATTERN)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    connectToCurrencyService();
    
    // Cargar productos
    m_productModel->load();
    
    // Verificar alertas de stock bajo
    checkLowStockAlerts();
    
    m_initialized = true;
    
    Logger::instance().info(
        QString("‚úì InventoryService inicializado - %1 productos cargados")
            .arg(m_productModel->count()),
        "Inventory"
    );
}

void InventoryService::connectToCurrencyService() {
    auto& currencyService = CurrencyService::instance();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OBSERVER: Escuchar cambios de tasa de cambio
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Conexi√≥n simple para actualizaciones
    connect(
        &currencyService,
        &CurrencyService::exchangeRateChanged,
        this,
        &InventoryService::onExchangeRateChanged
    );
    
    // Conexi√≥n detallada para logging y analytics
    connect(
        &currencyService,
        &CurrencyService::rateUpdated,
        this,
        &InventoryService::onRateUpdated
    );
    
    Logger::instance().info(
        "‚úì InventoryService conectado a CurrencyService (Observer)",
        "Inventory"
    );
}

//==============================================================================
// Slots Observer
//==============================================================================
void InventoryService::onExchangeRateChanged(double newRate) {
    Logger::instance().info(
        QString("üìä Recibido cambio de tasa: %1 - Recalculando precios...")
            .arg(newRate, 0, 'f', 2),
        "Inventory"
    );
    
    // Recalcular todos los precios en el modelo (que tambi√©n actualiza la BD)
    m_productModel->recalculatePrices(newRate);
    
    // Emitir se√±al propia
    emit exchangeRateUpdated(newRate);
}

void InventoryService::onRateUpdated(double newRate, double previousRate, double changePercent) {
    Logger::instance().info(
        QString("üí± Cambio de tasa detallado: %1 ‚Üí %2 (%3%4%)")
            .arg(previousRate, 0, 'f', 2)
            .arg(newRate, 0, 'f', 2)
            .arg(changePercent >= 0 ? "+" : "")
            .arg(changePercent, 0, 'f', 2),
        "Inventory"
    );
    
    int productCount = m_productModel->count();
    emit pricesRecalculated(productCount, newRate);
}

//==============================================================================
// Propiedades
//==============================================================================
ProductModel* InventoryService::products() {
    return m_productModel.get();
}

QVariantMap InventoryService::statistics() const {
    if (m_statisticsDirty) {
        m_cachedStatistics = m_repository->getStatistics();
        m_cachedStatistics["currentRate"] = currentExchangeRate();
        m_statisticsDirty = false;
    }
    return m_cachedStatistics;
}

double InventoryService::currentExchangeRate() const {
    return CurrencyService::instance().exchangeRate();
}

QStringList InventoryService::categories() const {
    return m_repository->getCategories();
}

int InventoryService::totalProducts() const {
    return m_repository->count(Inventory::ProductFilter::Active);
}

int InventoryService::lowStockCount() const {
    return m_repository->count(Inventory::ProductFilter::LowStock);
}

int InventoryService::outOfStockCount() const {
    return m_repository->count(Inventory::ProductFilter::OutOfStock);
}

//==============================================================================
// M√©todos Q_INVOKABLE
//==============================================================================
qint64 InventoryService::addProduct(
    const QString& name,
    const QString& description,
    const QString& category,
    double costUsd,
    double marginPercent,
    int stockQuantity,
    const QString& sku,
    const QString& barcode
) {
    QVariantMap data;
    data["name"] = name;
    data["description"] = description;
    data["category"] = category;
    data["costUsd"] = costUsd;
    data["marginPercent"] = marginPercent;
    data["stockQuantity"] = stockQuantity;
    data["sku"] = sku;
    data["barcode"] = barcode;
    
    return addProductFromMap(data);
}

qint64 InventoryService::addProductFromMap(const QVariantMap& data) {
    qint64 id = m_productModel->addProduct(data);
    
    if (id > 0) {
        m_statisticsDirty = true;
        emit categoriesChanged();
    } else {
        emit errorOccurred(tr("Error al crear el producto"));
    }
    
    return id;
}

bool InventoryService::updateProduct(qint64 id, const QVariantMap& data) {
    bool success = m_productModel->updateProduct(id, data);
    
    if (success) {
        m_statisticsDirty = true;
    } else {
        emit errorOccurred(tr("Error al actualizar el producto"));
    }
    
    return success;
}

bool InventoryService::deleteProduct(qint64 id) {
    bool success = m_productModel->deleteProduct(id);
    
    if (success) {
        m_statisticsDirty = true;
    }
    
    return success;
}

QVariantMap InventoryService::getProduct(qint64 id) const {
    auto product = m_repository->findById(id);
    if (product) {
        return product->toVariantMap();
    }
    return {};
}

QVariantMap InventoryService::findByBarcode(const QString& barcode) const {
    auto product = m_repository->findByBarcode(barcode);
    if (product) {
        return product->toVariantMap();
    }
    return {};
}

QVariantMap InventoryService::findBySku(const QString& sku) const {
    auto product = m_repository->findBySku(sku);
    if (product) {
        return product->toVariantMap();
    }
    return {};
}

bool InventoryService::updateStock(qint64 productId, int newQuantity) {
    bool success = m_productModel->updateStock(productId, newQuantity);
    
    if (success) {
        m_statisticsDirty = true;
        checkLowStockAlerts();
    }
    
    return success;
}

bool InventoryService::adjustStock(qint64 productId, int delta) {
    bool success = m_productModel->adjustStock(productId, delta);
    
    if (success) {
        m_statisticsDirty = true;
        checkLowStockAlerts();
    }
    
    return success;
}

double InventoryService::calculateSalePrice(double costUsd, double marginPercent) const {
    return CurrencyService::instance().calculateSalePrice(costUsd, marginPercent);
}

QString InventoryService::formatPrice(double amount) const {
    return CurrencyService::instance().formatLocal(amount);
}

void InventoryService::refresh() {
    m_productModel->load();
    m_statisticsDirty = true;
    emit statisticsChanged();
    emit categoriesChanged();
}

QVariantList InventoryService::getLowStockProducts() const {
    auto products = m_repository->findLowStock();
    
    QVariantList result;
    for (const auto& p : products) {
        result.append(p.toVariantMap());
    }
    
    return result;
}

QVariantList InventoryService::getOutOfStockProducts() const {
    auto products = m_repository->findOutOfStock();
    
    QVariantList result;
    for (const auto& p : products) {
        result.append(p.toVariantMap());
    }
    
    return result;
}

QVariantList InventoryService::exportInventory() const {
    auto products = m_repository->findAll(Inventory::ProductFilter::All);
    
    QVariantList result;
    for (const auto& p : products) {
        result.append(p.toVariantMap());
    }
    
    return result;
}

//==============================================================================
// Helpers privados
//==============================================================================
void InventoryService::updateStatistics() {
    m_statisticsDirty = true;
    emit statisticsChanged();
}

void InventoryService::checkLowStockAlerts() {
    int lowCount = lowStockCount();
    if (lowCount > 0) {
        Logger::instance().warning(
            QString("‚ö†Ô∏è Alerta: %1 productos con stock bajo").arg(lowCount),
            "Inventory"
        );
        emit lowStockAlert(lowCount);
    }
}

} // namespace Vento
```

---

## üìÑ src/features/inventory/CMakeLists.txt

```cmake
#===============================================================================
# src/features/inventory/CMakeLists.txt
# Vento - Feature Inventory
#===============================================================================

set(INVENTORY_SOURCES
    ProductRepository.cpp
    ProductModel.cpp
    InventoryService.cpp
)

set(INVENTORY_HEADERS
    InventoryTypes.hpp
    Product.hpp
    ProductRepository.hpp
    ProductModel.hpp
    InventoryService.hpp
)

#===============================================================================
# Biblioteca
#===============================================================================
add_library(VentoInventory STATIC
    ${INVENTORY_SOURCES}
    ${INVENTORY_HEADERS}
)

add_library(Vento::Inventory ALIAS VentoInventory)

#===============================================================================
# Configuraci√≥n
#===============================================================================
target_include_directories(VentoInventory
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_CURRENT_SOURCE_DIR}/..
)

target_link_libraries(VentoInventory
    PUBLIC
        Qt6::Core
        Qt6::Qml
        Vento::Core
        Vento::Currency  # Dependencia para Observer
)

target_compile_features(VentoInventory PUBLIC cxx_std_20)
```

---

## üìÑ Vista QML para Inventario (src/ui/qml/views/InventoryView.qml)

```qml
//==============================================================================
// InventoryView.qml
// Vento - Vista de gesti√≥n de inventario
//==============================================================================

import QtQuick
import QtQuick.Controls
import QtQuick.Controls.Material
import QtQuick.Layouts
import QtQuick.Dialogs

import Vento.Inventory 1.0
import Vento.Currency 1.0

Item {
    id: inventoryView
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    readonly property var appColors: ({
        primary: "#0078D4",
        success: "#107C10",
        warning: "#FF8C00",
        danger: "#D13438",
        surface: "#FFFFFF",
        background: "#F3F3F3"
    })
    
    //==========================================================================
    // Layout principal
    //==========================================================================
    ColumnLayout {
        anchors.fill: parent
        anchors.margins: 24
        spacing: 20
        
        //----------------------------------------------------------------------
        // Header con estad√≠sticas
        //----------------------------------------------------------------------
        RowLayout {
            Layout.fillWidth: true
            spacing: 16
            
            // T√≠tulo
            Label {
                text: "üì¶ Inventario"
                font.pixelSize: 28
                font.weight: Font.Bold
                color: appColors.primary
            }
            
            Item { Layout.fillWidth: true }
            
            // Stats cards
            Repeater {
                model: [
                    { 
                        label: "Total Productos", 
                        value: InventoryService.totalProducts,
                        color: appColors.primary,
                        icon: "üì¶"
                    },
                    { 
                        label: "Stock Bajo", 
                        value: InventoryService.lowStockCount,
                        color: appColors.warning,
                        icon: "‚ö†Ô∏è"
                    },
                    { 
                        label: "Agotados", 
                        value: InventoryService.outOfStockCount,
                        color: appColors.danger,
                        icon: "üö´"
                    }
                ]
                
                delegate: Pane {
                    Layout.preferredWidth: 150
                    Material.elevation: 2
                    
                    ColumnLayout {
                        anchors.fill: parent
                        spacing: 4
                        
                        Label {
                            text: modelData.icon + " " + modelData.value
                            font.pixelSize: 24
                            font.weight: Font.Bold
                            color: modelData.color
                        }
                        
                        Label {
                            text: modelData.label
                            font.pixelSize: 12
                            color: "#666"
                        }
                    }
                }
            }
            
            // Bot√≥n a√±adir
            Button {
                text: "+ Nuevo Producto"
                Material.background: appColors.primary
                Material.foreground: "white"
                
                onClicked: addProductDialog.open()
            }
        }
        
        //----------------------------------------------------------------------
        // Barra de b√∫squeda y filtros
        //----------------------------------------------------------------------
        Pane {
            Layout.fillWidth: true
            Material.elevation: 1
            
            RowLayout {
                anchors.fill: parent
                spacing: 16
                
                TextField {
                    id: searchField
                    Layout.preferredWidth: 300
                    placeholderText: "üîç Buscar productos..."
                    
                    onTextChanged: {
                        searchTimer.restart()
                    }
                    
                    Timer {
                        id: searchTimer
                        interval: 300
                        onTriggered: {
                            if (searchField.text.length >= 2) {
                                InventoryService.products.search(searchField.text)
                            } else if (searchField.text.length === 0) {
                                InventoryService.products.load()
                            }
                        }
                    }
                }
                
                ComboBox {
                    id: categoryFilter
                    Layout.preferredWidth: 200
                    model: ["Todas las categor√≠as"].concat(InventoryService.categories)
                    
                    onCurrentTextChanged: {
                        if (currentIndex === 0) {
                            InventoryService.products.setCategoryFilter("")
                        } else {
                            InventoryService.products.setCategoryFilter(currentText)
                        }
                    }
                }
                
                ComboBox {
                    id: sortCombo
                    Layout.preferredWidth: 180
                    model: [
                        { text: "Nombre (A-Z)", field: "name", asc: true },
                        { text: "Nombre (Z-A)", field: "name", asc: false },
                        { text: "Precio ‚Üë", field: "price", asc: true },
                        { text: "Precio ‚Üì", field: "price", asc: false },
                        { text: "Stock ‚Üë", field: "stock", asc: true },
                        { text: "Stock ‚Üì", field: "stock", asc: false }
                    ]
                    textRole: "text"
                    
                    onCurrentIndexChanged: {
                        let item = model[currentIndex]
                        InventoryService.products.sortBy(item.field, item.asc)
                    }
                }
                
                Item { Layout.fillWidth: true }
                
                Label {
                    text: InventoryService.products.count + " productos"
                    color: "#666"
                }
            }
        }
        
        //----------------------------------------------------------------------
        // Lista de productos
        //----------------------------------------------------------------------
        Pane {
            Layout.fillWidth: true
            Layout.fillHeight: true
            Material.elevation: 1
            padding: 0
            
            ListView {
                id: productList
                anchors.fill: parent
                anchors.margins: 1
                clip: true
                
                model: InventoryService.products
                
                // Header
                header: Rectangle {
                    width: productList.width
                    height: 48
                    color: "#F5F5F5"
                    
                    RowLayout {
                        anchors.fill: parent
                        anchors.leftMargin: 16
                        anchors.rightMargin: 16
                        spacing: 8
                        
                        Label { 
                            text: "Producto"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 250
                        }
                        Label { 
                            text: "Categor√≠a"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 120
                        }
                        Label { 
                            text: "Costo USD"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 100
                            horizontalAlignment: Text.AlignRight
                        }
                        Label { 
                            text: "Margen"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 80
                            horizontalAlignment: Text.AlignRight
                        }
                        Label { 
                            text: "Precio Venta"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 120
                            horizontalAlignment: Text.AlignRight
                        }
                        Label { 
                            text: "Stock"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 80
                            horizontalAlignment: Text.AlignCenter
                        }
                        Item { Layout.fillWidth: true }
                        Label { 
                            text: "Acciones"
                            font.weight: Font.Bold
                            Layout.preferredWidth: 100
                        }
                    }
                }
                
                delegate: Rectangle {
                    width: productList.width
                    height: 60
                    color: index % 2 === 0 ? "white" : "#FAFAFA"
                    
                    // Indicador de stock bajo
                    Rectangle {
                        width: 4
                        height: parent.height
                        color: {
                            if (model.stockStatus === "out") return appColors.danger
                            if (model.stockStatus === "low") return appColors.warning
                            return "transparent"
                        }
                    }
                    
                    RowLayout {
                        anchors.fill: parent
                        anchors.leftMargin: 16
                        anchors.rightMargin: 16
                        spacing: 8
                        
                        // Nombre y descripci√≥n
                        ColumnLayout {
                            Layout.preferredWidth: 250
                            spacing: 2
                            
                            Label {
                                text: model.name
                                font.weight: Font.Medium
                                elide: Text.ElideRight
                                Layout.fillWidth: true
                            }
                            Label {
                                text: model.sku || model.barcode || ""
                                font.pixelSize: 11
                                color: "#888"
                                visible: text !== ""
                            }
                        }
                        
                        // Categor√≠a
                        Label {
                            text: model.category || "-"
                            Layout.preferredWidth: 120
                            elide: Text.ElideRight
                        }
                        
                        // Costo USD
                        Label {
                            text: model.formattedCostUsd
                            Layout.preferredWidth: 100
                            horizontalAlignment: Text.AlignRight
                            font.family: "monospace"
                        }
                        
                        // Margen
                        Label {
                            text: model.marginPercent.toFixed(1) + "%"
                            Layout.preferredWidth: 80
                            horizontalAlignment: Text.AlignRight
                            color: model.marginPercent >= 30 ? appColors.success : "#666"
                        }
                        
                        // Precio de venta
                        Label {
                            text: model.formattedSalePrice
                            Layout.preferredWidth: 120
                            horizontalAlignment: Text.AlignRight
                            font.weight: Font.Bold
                            font.family: "monospace"
                            color: appColors.primary
                        }
                        
                        // Stock
                        Rectangle {
                            Layout.preferredWidth: 80
                            Layout.preferredHeight: 28
                            radius: 14
                            color: {
                                if (model.stockStatus === "out") return "#FFEBEE"
                                if (model.stockStatus === "low") return "#FFF3E0"
                                return "#E8F5E9"
                            }
                            
                            Label {
                                anchors.centerIn: parent
                                text: model.stockQuantity
                                font.weight: Font.Bold
                                color: {
                                    if (model.stockStatus === "out") return appColors.danger
                                    if (model.stockStatus === "low") return appColors.warning
                                    return appColors.success
                                }
                            }
                        }
                        
                        Item { Layout.fillWidth: true }
                        
                        // Acciones
                        Row {
                            Layout.preferredWidth: 100
                            spacing: 4
                            
                            ToolButton {
                                icon.source: "qrc:/icons/edit.svg"
                                icon.width: 18
                                icon.height: 18
                                
                                ToolTip.visible: hovered
                                ToolTip.text: "Editar"
                                
                                onClicked: {
                                    editProductDialog.productId = model.id
                                    editProductDialog.loadProduct(model.id)
                                    editProductDialog.open()
                                }
                            }
                            
                            ToolButton {
                                icon.source: "qrc:/icons/delete.svg"
                                icon.width: 18
                                icon.height: 18
                                
                                ToolTip.visible: hovered
                                ToolTip.text: "Eliminar"
                                
                                onClicked: {
                                    deleteConfirmDialog.productId = model.id
                                    deleteConfirmDialog.productName = model.name
                                    deleteConfirmDialog.open()
                                }
                            }
                        }
                    }
                    
                    // Hover effect
                    MouseArea {
                        anchors.fill: parent
                        hoverEnabled: true
                        
                        onEntered: parent.color = "#F0F7FF"
                        onExited: parent.color = index % 2 === 0 ? "white" : "#FAFAFA"
                    }
                }
                
                // Empty state
                Label {
                    anchors.centerIn: parent
                    text: "üì¶ No hay productos\nHaz clic en '+ Nuevo Producto' para a√±adir uno"
                    horizontalAlignment: Text.AlignHCenter
                    color: "#888"
                    visible: productList.count === 0
                }
            }
        }
    }
    
    //==========================================================================
    // Di√°logo: A√±adir Producto
    //==========================================================================
    Dialog {
        id: addProductDialog
        title: "Nuevo Producto"
        modal: true
        anchors.centerIn: parent
        width: 500
        
        standardButtons: Dialog.Ok | Dialog.Cancel
        
        onAccepted: {
            let id = InventoryService.addProduct(
                nameField.text,
                descField.text,
                categoryField.text,
                parseFloat(costField.text) || 0,
                parseFloat(marginField.text) || 30,
                parseInt(stockField.text) || 0,
                skuField.text,
                barcodeField.text
            )
            
            if (id > 0) {
                clearForm()
            }
        }
        
        function clearForm() {
            nameField.text = ""
            descField.text = ""
            categoryField.text = ""
            costField.text = ""
            marginField.text = "30"
            stockField.text = "0"
            skuField.text = ""
            barcodeField.text = ""
        }
        
        onOpened: nameField.forceActiveFocus()
        
        ColumnLayout {
            anchors.fill: parent
            spacing: 16
            
            GridLayout {
                columns: 2
                columnSpacing: 16
                rowSpacing: 12
                Layout.fillWidth: true
                
                Label { text: "Nombre *" }
                TextField {
                    id: nameField
                    Layout.fillWidth: true
                    placeholderText: "Nombre del producto"
                }
                
                Label { text: "Descripci√≥n" }
                TextField {
                    id: descField
                    Layout.fillWidth: true
                    placeholderText: "Descripci√≥n opcional"
                }
                
                Label { text: "Categor√≠a" }
                ComboBox {
                    id: categoryField
                    Layout.fillWidth: true
                    editable: true
                    model: InventoryService.categories
                }
                
                Label { text: "Costo USD *" }
                TextField {
                    id: costField
                    Layout.fillWidth: true
                    placeholderText: "0.00"
                    validator: DoubleValidator { bottom: 0; decimals: 2 }
                    
                    onTextChanged: updatePreview()
                }
                
                Label { text: "Margen %" }
                TextField {
                    id: marginField
                    Layout.fillWidth: true
                    text: "30"
                    validator: DoubleValidator { bottom: 0; top: 500; decimals: 1 }
                    
                    onTextChanged: updatePreview()
                }
                
                Label { text: "Stock inicial" }
                SpinBox {
                    id: stockField
                    Layout.fillWidth: true
                    from: 0
                    to: 99999
                    value: 0
                    editable: true
                }
                
                Label { text: "SKU" }
                TextField {
                    id: skuField
                    Layout.fillWidth: true
                    placeholderText: "C√≥digo interno"
                }
                
                Label { text: "C√≥digo de barras" }
                TextField {
                    id: barcodeField
                    Layout.fillWidth: true
                    placeholderText: "EAN/UPC"
                }
            }
            
            // Preview de precio
            Pane {
                Layout.fillWidth: true
                Material.background: "#F5F5F5"
                
                RowLayout {
                    anchors.fill: parent
                    
                    Label {
                        text: "Precio de venta calculado:"
                        color: "#666"
                    }
                    
                    Label {
                        id: pricePreview
                        text: CurrencyService.formatLocal(0)
                        font.pixelSize: 20
                        font.weight: Font.Bold
                        color: appColors.primary
                    }
                    
                    Item { Layout.fillWidth: true }
                    
                    Label {
                        text: "(Tasa: " + CurrencyService.exchangeRateFormatted + ")"
                        color: "#888"
                        font.pixelSize: 12
                    }
                }
            }
        }
        
        function updatePreview() {
            let cost = parseFloat(costField.text) || 0
            let margin = parseFloat(marginField.text) || 0
            let price = InventoryService.calculateSalePrice(cost, margin)
            pricePreview.text = CurrencyService.formatLocal(price)
        }
    }
    
    //==========================================================================
    // Di√°logo: Confirmar Eliminaci√≥n
    //==========================================================================
    Dialog {
        id: deleteConfirmDialog
        title: "Confirmar eliminaci√≥n"
        modal: true
        anchors.centerIn: parent
        
        property int productId: -1
        property string productName: ""
        
        standardButtons: Dialog.Yes | Dialog.No
        
        Label {
            text: "¬øEst√°s seguro de eliminar el producto\n'" + deleteConfirmDialog.productName + "'?"
        }
        
        onAccepted: {
            InventoryService.deleteProduct(productId)
        }
    }
    
    //==========================================================================
    // Conexiones
    //==========================================================================
    Connections {
        target: CurrencyService
        
        function onExchangeRateChanged(newRate) {
            // La UI se actualiza autom√°ticamente gracias a los bindings
            console.log("Inventario: Precios actualizados con tasa", newRate)
        }
    }
    
    Connections {
        target: InventoryService
        
        function onPricesRecalculated(count, rate) {
            // Mostrar notificaci√≥n
            console.log("Precios recalculados:", count, "productos a tasa", rate)
        }
        
        function onLowStockAlert(count) {
            console.log("‚ö†Ô∏è Alerta:", count, "productos con stock bajo")
        }
    }
}
```

---

## üìä Diagrama del Flujo Observer Completo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FLUJO COMPLETO: CAMBIO DE TASA                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                        ‚îÇ
‚îÇ  ‚îÇ  Usuario cambia ‚îÇ                                                        ‚îÇ
‚îÇ  ‚îÇ  tasa en QML UI ‚îÇ                                                        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                        ‚îÇ
‚îÇ           ‚îÇ                                                                  ‚îÇ
‚îÇ           ‚ñº                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                     CurrencyService                                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  1. updateRateFromSource(36.50, "manual")                   ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  2. Guarda en BD via CurrencyRepository                     ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  3. emit exchangeRateChanged(36.50)  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  4. emit rateUpdated(36.50, 35.00, +4.28%)             ‚îÇ    ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                               ‚îÇ             ‚îÇ
‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ       ‚îÇ                                                                      ‚îÇ
‚îÇ       ‚ñº                                                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                     InventoryService                                 ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  onExchangeRateChanged(36.50) [SLOT]                        ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                                                           ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚ñ∫ m_productModel->recalculatePrices(36.50)              ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                   ‚îÇ          ‚îÇ
‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ       ‚îÇ                                                                      ‚îÇ
‚îÇ       ‚ñº                                                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                      ProductModel                                    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  recalculatePrices(36.50)                                   ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ‚ñ∫ 1. m_repository->recalculateAllPrices(36.50)         ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ       ‚îî‚îÄ‚îÄ SQL: UPDATE products SET                       ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                 cost_local = cost_usd * 36.50,          ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                 sale_price = cost_usd * 36.50 *         ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                             (1 + margin_percent/100)     ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                 WHERE is_active = 1                      ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ‚ñ∫ 2. Actualizar m_products[] en memoria                ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚ñ∫ 3. emit dataChanged(0, count-1, {SalePriceRole...}) ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                   ‚îÇ          ‚îÇ
‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ       ‚îÇ                                                                      ‚îÇ
‚îÇ       ‚ñº                                                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                         QML ListView                                 ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Los delegates se actualizan autom√°ticamente porque         ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  los bindings detectan los cambios en los roles:            ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                              ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ    Label { text: model.formattedSalePrice }  ‚óÑ‚îÄ‚îÄ SE ACTUALIZA‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ    Label { text: model.formattedCostLocal }  ‚óÑ‚îÄ‚îÄ SE ACTUALIZA‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                              ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚úì Sin necesidad de recargar la lista completa              ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚úì Solo se re-renderizan los elementos visibles             ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ Resumen de lo Implementado

| Componente | Responsabilidad | Patr√≥n/Principio |
|------------|-----------------|------------------|
| `Product.hpp` | Estructura de datos | Value Object |
| `ProductRepository` | Persistencia SQL | Repository, SRP |
| `ProductModel` | Modelo para QML | Adapter (QAbstractListModel) |
| `InventoryService` | L√≥gica + Observer | Facade, Observer, Singleton |
| `recalculatePrices()` | Batch update eficiente | Transaction Pattern |

---

## üîë Puntos Clave de la Implementaci√≥n

1. **Transacciones SQL**: `recalculateAllPrices()` usa una sola transacci√≥n para actualizar todos los productos.

2. **Actualizaci√≥n en memoria + BD**: Primero actualiza la BD, luego sincroniza el modelo en memoria.

3. **Notificaci√≥n granular**: `dataChanged()` emite solo los roles que cambiaron, no todo el modelo.

4. **F√≥rmula de precio**:
   ```
   cost_local = cost_usd √ó exchange_rate
   sale_price = cost_local √ó (1 + margin_percent / 100)
   ```

5. **Conexi√≥n Observer**: `InventoryService` se conecta a `CurrencyService::exchangeRateChanged` en `initialize()`.

---

¬øContinuamos con el **Feature Sales** para registrar ventas y descontar del inventario? üöÄ
