# Vento - Feature Sales (Ventas)

Implementaremos el sistema de ventas completo con registro de transacciones, descuento autom√°tico de stock y conexi√≥n con los otros m√≥dulos.

## üìÅ Estructura del Feature

```
src/features/sales/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ SalesTypes.hpp           # Tipos y constantes
‚îú‚îÄ‚îÄ Sale.hpp                 # Estructura de venta
‚îú‚îÄ‚îÄ SaleItem.hpp             # Items de una venta
‚îú‚îÄ‚îÄ SalesRepository.hpp      # Capa de persistencia
‚îú‚îÄ‚îÄ SalesRepository.cpp
‚îú‚îÄ‚îÄ SalesModel.hpp           # QAbstractListModel para historial
‚îú‚îÄ‚îÄ SalesModel.cpp
‚îú‚îÄ‚îÄ CartModel.hpp            # Modelo del carrito de compras
‚îú‚îÄ‚îÄ CartModel.cpp
‚îú‚îÄ‚îÄ SalesService.hpp         # Servicio principal (Controller)
‚îî‚îÄ‚îÄ SalesService.cpp
```

---

## üìÑ src/features/sales/SalesTypes.hpp

```cpp
//==============================================================================
// SalesTypes.hpp
// Vento - Tipos y constantes para el m√≥dulo Sales
//==============================================================================
#pragma once

#include <QString>
#include <QObject>
#include <QDateTime>

namespace Vento::Sales {

//==============================================================================
// Constantes del m√≥dulo
//==============================================================================
namespace Defaults {
    constexpr double DEFAULT_TAX_PERCENT = 16.0;
    constexpr double MIN_SALE_AMOUNT = 0.01;
    constexpr int MAX_QUANTITY_PER_ITEM = 9999;
}

//==============================================================================
// Estados de venta
//==============================================================================
enum class SaleStatus {
    Pending,        // En proceso
    Completed,      // Completada
    Cancelled,      // Cancelada
    Refunded,       // Reembolsada
    PartialRefund   // Reembolso parcial
};

inline QString statusToString(SaleStatus status) {
    switch (status) {
        case SaleStatus::Pending:       return "pending";
        case SaleStatus::Completed:     return "completed";
        case SaleStatus::Cancelled:     return "cancelled";
        case SaleStatus::Refunded:      return "refunded";
        case SaleStatus::PartialRefund: return "partial_refund";
        default: return "completed";
    }
}

inline SaleStatus stringToStatus(const QString& str) {
    if (str == "pending") return SaleStatus::Pending;
    if (str == "cancelled") return SaleStatus::Cancelled;
    if (str == "refunded") return SaleStatus::Refunded;
    if (str == "partial_refund") return SaleStatus::PartialRefund;
    return SaleStatus::Completed;
}

inline QString statusDisplayName(SaleStatus status) {
    switch (status) {
        case SaleStatus::Pending:       return QObject::tr("Pendiente");
        case SaleStatus::Completed:     return QObject::tr("Completada");
        case SaleStatus::Cancelled:     return QObject::tr("Cancelada");
        case SaleStatus::Refunded:      return QObject::tr("Reembolsada");
        case SaleStatus::PartialRefund: return QObject::tr("Reembolso Parcial");
        default: return QObject::tr("Desconocido");
    }
}

//==============================================================================
// M√©todos de pago
//==============================================================================
enum class PaymentMethod {
    Cash,           // Efectivo
    Card,           // Tarjeta
    Transfer,       // Transferencia
    Mobile,         // Pago m√≥vil
    Mixed,          // Mixto
    Credit          // Cr√©dito/Fiado
};

inline QString paymentToString(PaymentMethod method) {
    switch (method) {
        case PaymentMethod::Cash:     return "cash";
        case PaymentMethod::Card:     return "card";
        case PaymentMethod::Transfer: return "transfer";
        case PaymentMethod::Mobile:   return "mobile";
        case PaymentMethod::Mixed:    return "mixed";
        case PaymentMethod::Credit:   return "credit";
        default: return "cash";
    }
}

inline PaymentMethod stringToPayment(const QString& str) {
    if (str == "card") return PaymentMethod::Card;
    if (str == "transfer") return PaymentMethod::Transfer;
    if (str == "mobile") return PaymentMethod::Mobile;
    if (str == "mixed") return PaymentMethod::Mixed;
    if (str == "credit") return PaymentMethod::Credit;
    return PaymentMethod::Cash;
}

inline QString paymentDisplayName(PaymentMethod method) {
    switch (method) {
        case PaymentMethod::Cash:     return QObject::tr("Efectivo");
        case PaymentMethod::Card:     return QObject::tr("Tarjeta");
        case PaymentMethod::Transfer: return QObject::tr("Transferencia");
        case PaymentMethod::Mobile:   return QObject::tr("Pago M√≥vil");
        case PaymentMethod::Mixed:    return QObject::tr("Mixto");
        case PaymentMethod::Credit:   return QObject::tr("Cr√©dito");
        default: return QObject::tr("Efectivo");
    }
}

//==============================================================================
// Roles para QAbstractListModel
//==============================================================================
namespace Roles {
    enum SaleRoles {
        IdRole = Qt::UserRole + 1,
        SaleDateRole,
        SubtotalRole,
        TaxPercentRole,
        TaxAmountRole,
        DiscountAmountRole,
        TotalRole,
        ExchangeRateRole,
        PaymentMethodRole,
        PaymentMethodDisplayRole,
        CustomerNameRole,
        StatusRole,
        StatusDisplayRole,
        NotesRole,
        ItemCountRole,
        FormattedTotalRole,
        FormattedDateRole,
        FormattedTimeRole
    };
    
    enum CartItemRoles {
        ProductIdRole = Qt::UserRole + 1,
        ProductNameRole,
        UnitPriceRole,
        QuantityRole,
        SubtotalRole,
        FormattedUnitPriceRole,
        FormattedSubtotalRole,
        MaxStockRole
    };
}

//==============================================================================
// Resultado de operaci√≥n de venta
//==============================================================================
struct SaleResult {
    bool success = false;
    QString errorMessage;
    qint64 saleId = -1;
    double total = 0.0;
    
    explicit operator bool() const { return success; }
    
    static SaleResult ok(qint64 id, double total) {
        return {true, {}, id, total};
    }
    
    static SaleResult error(const QString& message) {
        return {false, message, -1, 0.0};
    }
};

//==============================================================================
// Filtros de ventas
//==============================================================================
enum class SaleFilter {
    All,
    Today,
    ThisWeek,
    ThisMonth,
    Completed,
    Cancelled,
    DateRange
};

} // namespace Vento::Sales

Q_DECLARE_METATYPE(Vento::Sales::SaleStatus)
Q_DECLARE_METATYPE(Vento::Sales::PaymentMethod)
Q_DECLARE_METATYPE(Vento::Sales::SaleFilter)
```

---

## üìÑ src/features/sales/SaleItem.hpp

```cpp
//==============================================================================
// SaleItem.hpp
// Vento - Estructura de item de venta (detalle)
//==============================================================================
#pragma once

#include <QString>
#include <QVariantMap>

namespace Vento {

//==============================================================================
// SaleItem - Item individual de una venta
//==============================================================================
struct SaleItem {
    qint64 id = 0;
    qint64 saleId = 0;
    qint64 productId = 0;
    
    // Snapshot del producto al momento de la venta
    QString productName;
    double unitPrice = 0.0;
    int quantity = 1;
    double subtotal = 0.0;
    
    QDateTime createdAt;
    
    //==========================================================================
    // C√°lculos
    //==========================================================================
    
    void calculateSubtotal() {
        subtotal = unitPrice * quantity;
    }
    
    //==========================================================================
    // Validaci√≥n
    //==========================================================================
    
    [[nodiscard]] bool isValid() const {
        return productId > 0 && 
               !productName.isEmpty() && 
               quantity > 0 && 
               unitPrice >= 0;
    }
    
    //==========================================================================
    // Serializaci√≥n
    //==========================================================================
    
    [[nodiscard]] QVariantMap toVariantMap() const {
        return {
            {"id", id},
            {"saleId", saleId},
            {"productId", productId},
            {"productName", productName},
            {"unitPrice", unitPrice},
            {"quantity", quantity},
            {"subtotal", subtotal}
        };
    }
    
    static SaleItem fromVariantMap(const QVariantMap& map) {
        SaleItem item;
        item.id = map.value("id").toLongLong();
        item.saleId = map.value("saleId", map.value("sale_id")).toLongLong();
        item.productId = map.value("productId", map.value("product_id")).toLongLong();
        item.productName = map.value("productName", map.value("product_name")).toString();
        item.unitPrice = map.value("unitPrice", map.value("unit_price")).toDouble();
        item.quantity = map.value("quantity").toInt();
        item.subtotal = map.value("subtotal").toDouble();
        return item;
    }
};

//==============================================================================
// CartItem - Item en el carrito (antes de confirmar venta)
//==============================================================================
struct CartItem {
    qint64 productId = 0;
    QString productName;
    double unitPrice = 0.0;
    int quantity = 1;
    int maxStock = 0;  // Stock disponible
    
    [[nodiscard]] double subtotal() const {
        return unitPrice * quantity;
    }
    
    [[nodiscard]] bool canAddMore() const {
        return quantity < maxStock;
    }
    
    [[nodiscard]] QVariantMap toVariantMap() const {
        return {
            {"productId", productId},
            {"productName", productName},
            {"unitPrice", unitPrice},
            {"quantity", quantity},
            {"subtotal", subtotal()},
            {"maxStock", maxStock}
        };
    }
};

} // namespace Vento

Q_DECLARE_METATYPE(Vento::SaleItem)
Q_DECLARE_METATYPE(Vento::CartItem)
```

---

## üìÑ src/features/sales/Sale.hpp

```cpp
//==============================================================================
// Sale.hpp
// Vento - Estructura de venta (encabezado)
//==============================================================================
#pragma once

#include <QString>
#include <QDateTime>
#include <QList>
#include <QVariantMap>

#include "SaleItem.hpp"
#include "SalesTypes.hpp"

namespace Vento {

//==============================================================================
// Sale - Estructura principal de venta
//==============================================================================
struct Sale {
    qint64 id = 0;
    
    // Fecha y hora
    QDateTime saleDate;
    
    // Montos
    double subtotal = 0.0;
    double taxPercent = Sales::Defaults::DEFAULT_TAX_PERCENT;
    double taxAmount = 0.0;
    double discountAmount = 0.0;
    double total = 0.0;
    
    // Tasa de cambio al momento de la venta (para hist√≥rico)
    double exchangeRate = 1.0;
    
    // Pago
    Sales::PaymentMethod paymentMethod = Sales::PaymentMethod::Cash;
    
    // Cliente (opcional)
    QString customerName;
    QString customerId;
    
    // Estado
    Sales::SaleStatus status = Sales::SaleStatus::Completed;
    QString notes;
    
    // Items de la venta
    QList<SaleItem> items;
    
    // Timestamps
    QDateTime createdAt;
    
    //==========================================================================
    // C√°lculos
    //==========================================================================
    
    /// Calcula el subtotal sumando los items
    void calculateSubtotal() {
        subtotal = 0.0;
        for (const auto& item : items) {
            subtotal += item.subtotal;
        }
    }
    
    /// Calcula el impuesto
    void calculateTax() {
        taxAmount = subtotal * (taxPercent / 100.0);
    }
    
    /// Calcula el total
    void calculateTotal() {
        total = subtotal + taxAmount - discountAmount;
        if (total < 0) total = 0;
    }
    
    /// Calcula todos los montos
    void calculateAll() {
        calculateSubtotal();
        calculateTax();
        calculateTotal();
    }
    
    /// Obtiene el n√∫mero de items
    [[nodiscard]] int itemCount() const {
        int count = 0;
        for (const auto& item : items) {
            count += item.quantity;
        }
        return count;
    }
    
    /// Obtiene el total en USD
    [[nodiscard]] double totalInUsd() const {
        if (exchangeRate <= 0) return 0;
        return total / exchangeRate;
    }
    
    //==========================================================================
    // Validaci√≥n
    //==========================================================================
    
    [[nodiscard]] bool isValid() const {
        return !items.isEmpty() && total > 0;
    }
    
    [[nodiscard]] bool isCompleted() const {
        return status == Sales::SaleStatus::Completed;
    }
    
    [[nodiscard]] bool isCancellable() const {
        return status == Sales::SaleStatus::Completed ||
               status == Sales::SaleStatus::Pending;
    }
    
    //==========================================================================
    // Serializaci√≥n
    //==========================================================================
    
    [[nodiscard]] QVariantMap toVariantMap() const {
        QVariantList itemsList;
        for (const auto& item : items) {
            itemsList.append(item.toVariantMap());
        }
        
        return {
            {"id", id},
            {"saleDate", saleDate},
            {"subtotal", subtotal},
            {"taxPercent", taxPercent},
            {"taxAmount", taxAmount},
            {"discountAmount", discountAmount},
            {"total", total},
            {"exchangeRate", exchangeRate},
            {"paymentMethod", Sales::paymentToString(paymentMethod)},
            {"paymentMethodDisplay", Sales::paymentDisplayName(paymentMethod)},
            {"customerName", customerName},
            {"customerId", customerId},
            {"status", Sales::statusToString(status)},
            {"statusDisplay", Sales::statusDisplayName(status)},
            {"notes", notes},
            {"items", itemsList},
            {"itemCount", itemCount()},
            {"totalInUsd", totalInUsd()}
        };
    }
    
    static Sale fromVariantMap(const QVariantMap& map) {
        Sale sale;
        
        sale.id = map.value("id").toLongLong();
        sale.saleDate = map.value("saleDate", map.value("sale_date")).toDateTime();
        sale.subtotal = map.value("subtotal").toDouble();
        sale.taxPercent = map.value("taxPercent", map.value("tax_percent")).toDouble();
        sale.taxAmount = map.value("taxAmount", map.value("tax_amount")).toDouble();
        sale.discountAmount = map.value("discountAmount", map.value("discount_amount")).toDouble();
        sale.total = map.value("total").toDouble();
        sale.exchangeRate = map.value("exchangeRate", map.value("exchange_rate")).toDouble();
        sale.paymentMethod = Sales::stringToPayment(
            map.value("paymentMethod", map.value("payment_method")).toString()
        );
        sale.customerName = map.value("customerName", map.value("customer_name")).toString();
        sale.customerId = map.value("customerId", map.value("customer_id")).toString();
        sale.status = Sales::stringToStatus(map.value("status").toString());
        sale.notes = map.value("notes").toString();
        
        return sale;
    }
};

//==============================================================================
// SaleSummary - Resumen para listas
//==============================================================================
struct SaleSummary {
    qint64 id;
    QDateTime saleDate;
    double total;
    int itemCount;
    Sales::SaleStatus status;
    Sales::PaymentMethod paymentMethod;
    
    static SaleSummary fromSale(const Sale& sale) {
        return {
            sale.id,
            sale.saleDate,
            sale.total,
            sale.itemCount(),
            sale.status,
            sale.paymentMethod
        };
    }
};

} // namespace Vento

Q_DECLARE_METATYPE(Vento::Sale)
Q_DECLARE_METATYPE(Vento::SaleSummary)
```

---

## üìÑ src/features/sales/SalesRepository.hpp

```cpp
//==============================================================================
// SalesRepository.hpp
// Vento - Repositorio de ventas (capa de persistencia)
//==============================================================================
#pragma once

#include <QObject>
#include <QList>
#include <QDate>
#include <optional>

#include "Sale.hpp"
#include "SaleItem.hpp"
#include "SalesTypes.hpp"

namespace Vento {

class SalesRepository : public QObject {
    Q_OBJECT
    
public:
    explicit SalesRepository(QObject* parent = nullptr);
    ~SalesRepository() override = default;
    
    //==========================================================================
    // Operaciones de Venta
    //==========================================================================
    
    /// Registra una nueva venta completa (con items)
    /// @param sale Venta a registrar
    /// @return ID de la venta creada o -1 si falla
    [[nodiscard]] qint64 createSale(const Sale& sale);
    
    /// Registra una venta simple (un solo producto)
    /// @param productId ID del producto
    /// @param productName Nombre del producto (snapshot)
    /// @param unitPrice Precio unitario
    /// @param quantity Cantidad
    /// @param exchangeRate Tasa de cambio actual
    /// @param paymentMethod M√©todo de pago
    /// @return Resultado de la operaci√≥n
    [[nodiscard]] Sales::SaleResult registerQuickSale(
        qint64 productId,
        const QString& productName,
        double unitPrice,
        int quantity,
        double exchangeRate,
        Sales::PaymentMethod paymentMethod = Sales::PaymentMethod::Cash
    );
    
    /// Obtiene una venta por ID (con items)
    [[nodiscard]] std::optional<Sale> findById(qint64 id);
    
    /// Actualiza el estado de una venta
    [[nodiscard]] bool updateStatus(qint64 saleId, Sales::SaleStatus newStatus);
    
    /// Cancela una venta (y restaura el stock)
    [[nodiscard]] bool cancelSale(qint64 saleId);
    
    //==========================================================================
    // Consultas
    //==========================================================================
    
    /// Obtiene todas las ventas seg√∫n filtro
    [[nodiscard]] QList<Sale> findAll(
        Sales::SaleFilter filter = Sales::SaleFilter::All,
        int limit = 100
    );
    
    /// Obtiene ventas por rango de fechas
    [[nodiscard]] QList<Sale> findByDateRange(
        const QDate& startDate,
        const QDate& endDate
    );
    
    /// Obtiene ventas de hoy
    [[nodiscard]] QList<Sale> findToday();
    
    /// Obtiene las √∫ltimas N ventas
    [[nodiscard]] QList<Sale> findRecent(int limit = 20);
    
    /// Busca ventas por cliente
    [[nodiscard]] QList<Sale> findByCustomer(const QString& customerName);
    
    /// Obtiene los items de una venta
    [[nodiscard]] QList<SaleItem> getSaleItems(qint64 saleId);
    
    /// Cuenta ventas seg√∫n filtro
    [[nodiscard]] int count(Sales::SaleFilter filter = Sales::SaleFilter::All);
    
    //==========================================================================
    // Estad√≠sticas
    //==========================================================================
    
    /// Obtiene el total de ventas del d√≠a
    [[nodiscard]] double getTodayTotal();
    
    /// Obtiene el total de ventas de la semana
    [[nodiscard]] double getWeekTotal();
    
    /// Obtiene el total de ventas del mes
    [[nodiscard]] double getMonthTotal();
    
    /// Obtiene estad√≠sticas generales
    [[nodiscard]] QVariantMap getStatistics();
    
    /// Obtiene ventas por m√©todo de pago (para gr√°ficos)
    [[nodiscard]] QVariantMap getSalesByPaymentMethod(const QDate& date = QDate::currentDate());
    
    /// Obtiene los productos m√°s vendidos
    [[nodiscard]] QVariantList getTopProducts(int limit = 10, const QDate& startDate = QDate());
    
    //==========================================================================
    // Operaciones de Stock (internas)
    //==========================================================================
    
    /// Descuenta el stock de un producto
    [[nodiscard]] bool decreaseStock(qint64 productId, int quantity);
    
    /// Restaura el stock de un producto (para cancelaciones)
    [[nodiscard]] bool restoreStock(qint64 productId, int quantity);
    
private:
    /// Construye una Sale desde un row de la BD
    [[nodiscard]] Sale saleFromRow(const QVariantMap& row) const;
    
    /// Construye un SaleItem desde un row de la BD
    [[nodiscard]] SaleItem saleItemFromRow(const QVariantMap& row) const;
    
    /// Obtiene la cl√°usula WHERE para un filtro
    [[nodiscard]] QString buildFilterClause(Sales::SaleFilter filter) const;
};

} // namespace Vento
```

---

## üìÑ src/features/sales/SalesRepository.cpp

```cpp
//==============================================================================
// SalesRepository.cpp
// Vento - Implementaci√≥n del repositorio de ventas
//==============================================================================

#include "SalesRepository.hpp"
#include "core/database/DatabaseManager.hpp"
#include "core/logger/Logger.hpp"

#include <QSqlQuery>
#include <QSqlError>

namespace Vento {

//==============================================================================
// Constructor
//==============================================================================
SalesRepository::SalesRepository(QObject* parent) 
    : QObject(parent) 
{
    Logger::instance().debug("SalesRepository inicializado", "Sales");
}

//==============================================================================
// Crear Venta Completa
//==============================================================================
qint64 SalesRepository::createSale(const Sale& sale) {
    auto& db = DatabaseManager::instance();
    
    // Usar transacci√≥n para atomicidad
    auto result = db.executeInTransaction([&](QSqlQuery& query) {
        // 1. Insertar encabezado de venta
        query.prepare(R"(
            INSERT INTO sales (
                sale_date, subtotal, tax_percent, tax_amount,
                discount_amount, total, exchange_rate,
                payment_method, customer_name, customer_id,
                status, notes, created_at
            ) VALUES (
                ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                datetime('now', 'localtime')
            )
        )");
        
        query.addBindValue(sale.saleDate.isValid() ? 
            sale.saleDate.toString("yyyy-MM-dd hh:mm:ss") :
            QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss"));
        query.addBindValue(sale.subtotal);
        query.addBindValue(sale.taxPercent);
        query.addBindValue(sale.taxAmount);
        query.addBindValue(sale.discountAmount);
        query.addBindValue(sale.total);
        query.addBindValue(sale.exchangeRate);
        query.addBindValue(Sales::paymentToString(sale.paymentMethod));
        query.addBindValue(sale.customerName.isEmpty() ? QVariant() : sale.customerName);
        query.addBindValue(sale.customerId.isEmpty() ? QVariant() : sale.customerId);
        query.addBindValue(Sales::statusToString(sale.status));
        query.addBindValue(sale.notes.isEmpty() ? QVariant() : sale.notes);
        
        if (!query.exec()) {
            Logger::instance().error(
                QString("Error creando venta: %1").arg(query.lastError().text()),
                "Sales"
            );
            return false;
        }
        
        qint64 saleId = query.lastInsertId().toLongLong();
        
        // 2. Insertar items y descontar stock
        for (const auto& item : sale.items) {
            // Insertar item
            query.prepare(R"(
                INSERT INTO sale_items (
                    sale_id, product_id, product_name,
                    unit_price, quantity, subtotal, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, datetime('now', 'localtime'))
            )");
            
            query.addBindValue(saleId);
            query.addBindValue(item.productId);
            query.addBindValue(item.productName);
            query.addBindValue(item.unitPrice);
            query.addBindValue(item.quantity);
            query.addBindValue(item.subtotal);
            
            if (!query.exec()) {
                Logger::instance().error(
                    QString("Error insertando item: %1").arg(query.lastError().text()),
                    "Sales"
                );
                return false;
            }
            
            // Descontar stock
            query.prepare(R"(
                UPDATE products SET 
                    stock_quantity = stock_quantity - ?,
                    updated_at = datetime('now', 'localtime')
                WHERE id = ? AND stock_quantity >= ?
            )");
            
            query.addBindValue(item.quantity);
            query.addBindValue(item.productId);
            query.addBindValue(item.quantity);
            
            if (!query.exec() || query.numRowsAffected() == 0) {
                Logger::instance().error(
                    QString("Error descontando stock para producto %1")
                        .arg(item.productId),
                    "Sales"
                );
                return false;
            }
        }
        
        return true;
    });
    
    if (result) {
        // Obtener el ID de la venta reci√©n creada
        auto idResult = db.executeScalar("SELECT last_insert_rowid()");
        qint64 saleId = idResult ? idResult.data.toLongLong() : -1;
        
        Logger::instance().info(
            QString("‚úì Venta registrada: #%1 - Total: %2 (%3 items)")
                .arg(saleId)
                .arg(sale.total, 0, 'f', 2)
                .arg(sale.items.size()),
            "Sales"
        );
        
        return saleId;
    }
    
    return -1;
}

//==============================================================================
// Venta R√°pida (un solo producto)
//==============================================================================
Sales::SaleResult SalesRepository::registerQuickSale(
    qint64 productId,
    const QString& productName,
    double unitPrice,
    int quantity,
    double exchangeRate,
    Sales::PaymentMethod paymentMethod
) {
    // Validaciones
    if (productId <= 0) {
        return Sales::SaleResult::error("ID de producto inv√°lido");
    }
    
    if (quantity <= 0) {
        return Sales::SaleResult::error("Cantidad debe ser mayor a 0");
    }
    
    if (unitPrice < 0) {
        return Sales::SaleResult::error("Precio no puede ser negativo");
    }
    
    // Verificar stock disponible
    auto& db = DatabaseManager::instance();
    auto stockResult = db.executeScalar(
        "SELECT stock_quantity FROM products WHERE id = ? AND is_active = 1",
        {productId}
    );
    
    if (!stockResult || !stockResult.data.isValid()) {
        return Sales::SaleResult::error("Producto no encontrado");
    }
    
    int availableStock = stockResult.data.toInt();
    if (availableStock < quantity) {
        return Sales::SaleResult::error(
            QString("Stock insuficiente. Disponible: %1").arg(availableStock)
        );
    }
    
    // Crear la venta
    Sale sale;
    sale.saleDate = QDateTime::currentDateTime();
    sale.exchangeRate = exchangeRate;
    sale.paymentMethod = paymentMethod;
    sale.status = Sales::SaleStatus::Completed;
    
    // Crear el item
    SaleItem item;
    item.productId = productId;
    item.productName = productName;
    item.unitPrice = unitPrice;
    item.quantity = quantity;
    item.calculateSubtotal();
    
    sale.items.append(item);
    sale.calculateAll();
    
    // Registrar
    qint64 saleId = createSale(sale);
    
    if (saleId > 0) {
        return Sales::SaleResult::ok(saleId, sale.total);
    }
    
    return Sales::SaleResult::error("Error al registrar la venta");
}

//==============================================================================
// Obtener Venta por ID
//==============================================================================
std::optional<Sale> SalesRepository::findById(qint64 id) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM sales WHERE id = ?",
        {id}
    );
    
    if (rows.isEmpty()) {
        return std::nullopt;
    }
    
    Sale sale = saleFromRow(rows.first());
    sale.items = getSaleItems(id);
    
    return sale;
}

//==============================================================================
// Actualizar Estado
//==============================================================================
bool SalesRepository::updateStatus(qint64 saleId, Sales::SaleStatus newStatus) {
    auto result = DatabaseManager::instance().execute(
        "UPDATE sales SET status = ? WHERE id = ?",
        {Sales::statusToString(newStatus), saleId}
    );
    
    if (result) {
        Logger::instance().info(
            QString("Venta #%1 actualizada a estado: %2")
                .arg(saleId)
                .arg(Sales::statusDisplayName(newStatus)),
            "Sales"
        );
    }
    
    return result.success;
}

//==============================================================================
// Cancelar Venta
//==============================================================================
bool SalesRepository::cancelSale(qint64 saleId) {
    // Obtener la venta actual
    auto sale = findById(saleId);
    if (!sale) {
        Logger::instance().error(
            QString("Venta #%1 no encontrada para cancelar").arg(saleId),
            "Sales"
        );
        return false;
    }
    
    if (!sale->isCancellable()) {
        Logger::instance().warning(
            QString("Venta #%1 no puede ser cancelada (estado: %2)")
                .arg(saleId)
                .arg(Sales::statusDisplayName(sale->status)),
            "Sales"
        );
        return false;
    }
    
    auto& db = DatabaseManager::instance();
    
    // Transacci√≥n: actualizar estado y restaurar stock
    auto result = db.executeInTransaction([&](QSqlQuery& query) {
        // 1. Actualizar estado
        query.prepare("UPDATE sales SET status = ? WHERE id = ?");
        query.addBindValue(Sales::statusToString(Sales::SaleStatus::Cancelled));
        query.addBindValue(saleId);
        
        if (!query.exec()) {
            return false;
        }
        
        // 2. Restaurar stock de cada item
        for (const auto& item : sale->items) {
            query.prepare(R"(
                UPDATE products SET 
                    stock_quantity = stock_quantity + ?,
                    updated_at = datetime('now', 'localtime')
                WHERE id = ?
            )");
            
            query.addBindValue(item.quantity);
            query.addBindValue(item.productId);
            
            if (!query.exec()) {
                return false;
            }
        }
        
        return true;
    });
    
    if (result) {
        Logger::instance().info(
            QString("‚úì Venta #%1 cancelada, stock restaurado").arg(saleId),
            "Sales"
        );
    }
    
    return result.success;
}

//==============================================================================
// Consultas
//==============================================================================
QList<Sale> SalesRepository::findAll(Sales::SaleFilter filter, int limit) {
    QString sql = "SELECT * FROM sales";
    
    QString whereClause = buildFilterClause(filter);
    if (!whereClause.isEmpty()) {
        sql += " WHERE " + whereClause;
    }
    
    sql += " ORDER BY sale_date DESC";
    
    if (limit > 0) {
        sql += QString(" LIMIT %1").arg(limit);
    }
    
    auto rows = DatabaseManager::instance().executeQuery(sql);
    
    QList<Sale> sales;
    sales.reserve(rows.size());
    
    for (const auto& row : rows) {
        sales.append(saleFromRow(row));
    }
    
    return sales;
}

QList<Sale> SalesRepository::findByDateRange(const QDate& startDate, const QDate& endDate) {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT * FROM sales 
            WHERE date(sale_date) BETWEEN ? AND ?
            ORDER BY sale_date DESC
        )",
        {startDate.toString("yyyy-MM-dd"), endDate.toString("yyyy-MM-dd")}
    );
    
    QList<Sale> sales;
    for (const auto& row : rows) {
        sales.append(saleFromRow(row));
    }
    
    return sales;
}

QList<Sale> SalesRepository::findToday() {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT * FROM sales 
            WHERE date(sale_date) = date('now', 'localtime')
            ORDER BY sale_date DESC
        )"
    );
    
    QList<Sale> sales;
    for (const auto& row : rows) {
        sales.append(saleFromRow(row));
    }
    
    return sales;
}

QList<Sale> SalesRepository::findRecent(int limit) {
    return findAll(Sales::SaleFilter::All, limit);
}

QList<Sale> SalesRepository::findByCustomer(const QString& customerName) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM sales WHERE customer_name LIKE ? ORDER BY sale_date DESC",
        {"%" + customerName + "%"}
    );
    
    QList<Sale> sales;
    for (const auto& row : rows) {
        sales.append(saleFromRow(row));
    }
    
    return sales;
}

QList<SaleItem> SalesRepository::getSaleItems(qint64 saleId) {
    auto rows = DatabaseManager::instance().executeQuery(
        "SELECT * FROM sale_items WHERE sale_id = ? ORDER BY id",
        {saleId}
    );
    
    QList<SaleItem> items;
    items.reserve(rows.size());
    
    for (const auto& row : rows) {
        items.append(saleItemFromRow(row));
    }
    
    return items;
}

int SalesRepository::count(Sales::SaleFilter filter) {
    QString sql = "SELECT COUNT(*) FROM sales";
    
    QString whereClause = buildFilterClause(filter);
    if (!whereClause.isEmpty()) {
        sql += " WHERE " + whereClause;
    }
    
    auto result = DatabaseManager::instance().executeScalar(sql);
    return result ? result.data.toInt() : 0;
}

//==============================================================================
// Estad√≠sticas
//==============================================================================
double SalesRepository::getTodayTotal() {
    auto result = DatabaseManager::instance().executeScalar(
        R"(
            SELECT COALESCE(SUM(total), 0) FROM sales 
            WHERE date(sale_date) = date('now', 'localtime')
              AND status = 'completed'
        )"
    );
    
    return result ? result.data.toDouble() : 0.0;
}

double SalesRepository::getWeekTotal() {
    auto result = DatabaseManager::instance().executeScalar(
        R"(
            SELECT COALESCE(SUM(total), 0) FROM sales 
            WHERE sale_date >= datetime('now', '-7 days', 'localtime')
              AND status = 'completed'
        )"
    );
    
    return result ? result.data.toDouble() : 0.0;
}

double SalesRepository::getMonthTotal() {
    auto result = DatabaseManager::instance().executeScalar(
        R"(
            SELECT COALESCE(SUM(total), 0) FROM sales 
            WHERE strftime('%Y-%m', sale_date) = strftime('%Y-%m', 'now', 'localtime')
              AND status = 'completed'
        )"
    );
    
    return result ? result.data.toDouble() : 0.0;
}

QVariantMap SalesRepository::getStatistics() {
    QVariantMap stats;
    
    stats["todayTotal"] = getTodayTotal();
    stats["weekTotal"] = getWeekTotal();
    stats["monthTotal"] = getMonthTotal();
    stats["todayCount"] = count(Sales::SaleFilter::Today);
    stats["totalSales"] = count(Sales::SaleFilter::All);
    
    // Promedio de venta
    auto avgResult = DatabaseManager::instance().executeScalar(
        "SELECT AVG(total) FROM sales WHERE status = 'completed'"
    );
    stats["averageSale"] = avgResult ? avgResult.data.toDouble() : 0.0;
    
    return stats;
}

QVariantMap SalesRepository::getSalesByPaymentMethod(const QDate& date) {
    auto rows = DatabaseManager::instance().executeQuery(
        R"(
            SELECT payment_method, COUNT(*) as count, SUM(total) as total
            FROM sales 
            WHERE date(sale_date) = ? AND status = 'completed'
            GROUP BY payment_method
        )",
        {date.toString("yyyy-MM-dd")}
    );
    
    QVariantMap result;
    for (const auto& row : rows) {
        QVariantMap methodData;
        methodData["count"] = row["count"];
        methodData["total"] = row["total"];
        result[row["payment_method"].toString()] = methodData;
    }
    
    return result;
}

QVariantList SalesRepository::getTopProducts(int limit, const QDate& startDate) {
    QString sql = R"(
        SELECT 
            si.product_id,
            si.product_name,
            SUM(si.quantity) as total_quantity,
            SUM(si.subtotal) as total_revenue
        FROM sale_items si
        JOIN sales s ON s.id = si.sale_id
        WHERE s.status = 'completed'
    )";
    
    QVariantList params;
    
    if (startDate.isValid()) {
        sql += " AND date(s.sale_date) >= ?";
        params.append(startDate.toString("yyyy-MM-dd"));
    }
    
    sql += R"(
        GROUP BY si.product_id
        ORDER BY total_quantity DESC
        LIMIT ?
    )";
    params.append(limit);
    
    auto rows = DatabaseManager::instance().executeQuery(sql, params);
    
    QVariantList result;
    for (const auto& row : rows) {
        QVariantMap product;
        product["productId"] = row["product_id"];
        product["productName"] = row["product_name"];
        product["totalQuantity"] = row["total_quantity"];
        product["totalRevenue"] = row["total_revenue"];
        result.append(product);
    }
    
    return result;
}

//==============================================================================
// Stock Operations
//==============================================================================
bool SalesRepository::decreaseStock(qint64 productId, int quantity) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                stock_quantity = stock_quantity - ?,
                updated_at = datetime('now', 'localtime')
            WHERE id = ? AND stock_quantity >= ?
        )",
        {quantity, productId, quantity}
    );
    
    return result.success && result.data.toInt() > 0;
}

bool SalesRepository::restoreStock(qint64 productId, int quantity) {
    auto result = DatabaseManager::instance().execute(
        R"(
            UPDATE products SET 
                stock_quantity = stock_quantity + ?,
                updated_at = datetime('now', 'localtime')
            WHERE id = ?
        )",
        {quantity, productId}
    );
    
    return result.success;
}

//==============================================================================
// Helpers Privados
//==============================================================================
Sale SalesRepository::saleFromRow(const QVariantMap& row) const {
    Sale sale;
    
    sale.id = row["id"].toLongLong();
    sale.saleDate = QDateTime::fromString(
        row["sale_date"].toString(), 
        "yyyy-MM-dd hh:mm:ss"
    );
    sale.subtotal = row["subtotal"].toDouble();
    sale.taxPercent = row["tax_percent"].toDouble();
    sale.taxAmount = row["tax_amount"].toDouble();
    sale.discountAmount = row["discount_amount"].toDouble();
    sale.total = row["total"].toDouble();
    sale.exchangeRate = row["exchange_rate"].toDouble();
    sale.paymentMethod = Sales::stringToPayment(row["payment_method"].toString());
    sale.customerName = row["customer_name"].toString();
    sale.customerId = row["customer_id"].toString();
    sale.status = Sales::stringToStatus(row["status"].toString());
    sale.notes = row["notes"].toString();
    sale.createdAt = QDateTime::fromString(
        row["created_at"].toString(),
        "yyyy-MM-dd hh:mm:ss"
    );
    
    return sale;
}

SaleItem SalesRepository::saleItemFromRow(const QVariantMap& row) const {
    SaleItem item;
    
    item.id = row["id"].toLongLong();
    item.saleId = row["sale_id"].toLongLong();
    item.productId = row["product_id"].toLongLong();
    item.productName = row["product_name"].toString();
    item.unitPrice = row["unit_price"].toDouble();
    item.quantity = row["quantity"].toInt();
    item.subtotal = row["subtotal"].toDouble();
    item.createdAt = QDateTime::fromString(
        row["created_at"].toString(),
        "yyyy-MM-dd hh:mm:ss"
    );
    
    return item;
}

QString SalesRepository::buildFilterClause(Sales::SaleFilter filter) const {
    switch (filter) {
        case Sales::SaleFilter::Today:
            return "date(sale_date) = date('now', 'localtime')";
        case Sales::SaleFilter::ThisWeek:
            return "sale_date >= datetime('now', '-7 days', 'localtime')";
        case Sales::SaleFilter::ThisMonth:
            return "strftime('%Y-%m', sale_date) = strftime('%Y-%m', 'now', 'localtime')";
        case Sales::SaleFilter::Completed:
            return "status = 'completed'";
        case Sales::SaleFilter::Cancelled:
            return "status = 'cancelled'";
        case Sales::SaleFilter::All:
        default:
            return {};
    }
}

} // namespace Vento
```

---

## üìÑ src/features/sales/CartModel.hpp

```cpp
//==============================================================================
// CartModel.hpp
// Vento - Modelo del carrito de compras
//==============================================================================
#pragma once

#include <QAbstractListModel>
#include <QList>

#include "SaleItem.hpp"
#include "SalesTypes.hpp"

namespace Vento {

class CartModel : public QAbstractListModel {
    Q_OBJECT
    
    Q_PROPERTY(int count READ count NOTIFY countChanged)
    Q_PROPERTY(int totalItems READ totalItems NOTIFY cartChanged)
    Q_PROPERTY(double subtotal READ subtotal NOTIFY cartChanged)
    Q_PROPERTY(double taxAmount READ taxAmount NOTIFY cartChanged)
    Q_PROPERTY(double total READ total NOTIFY cartChanged)
    Q_PROPERTY(double taxPercent READ taxPercent WRITE setTaxPercent NOTIFY taxPercentChanged)
    Q_PROPERTY(double discountAmount READ discountAmount WRITE setDiscountAmount NOTIFY cartChanged)
    Q_PROPERTY(bool isEmpty READ isEmpty NOTIFY countChanged)
    
public:
    explicit CartModel(QObject* parent = nullptr);
    
    //==========================================================================
    // QAbstractListModel
    //==========================================================================
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role) const override;
    QHash<int, QByteArray> roleNames() const override;
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    [[nodiscard]] int count() const;
    [[nodiscard]] int totalItems() const;
    [[nodiscard]] double subtotal() const;
    [[nodiscard]] double taxAmount() const;
    [[nodiscard]] double total() const;
    [[nodiscard]] double taxPercent() const;
    [[nodiscard]] double discountAmount() const;
    [[nodiscard]] bool isEmpty() const;
    
    void setTaxPercent(double percent);
    void setDiscountAmount(double amount);
    
    //==========================================================================
    // M√©todos Q_INVOKABLE
    //==========================================================================
    
    /// A√±ade un producto al carrito
    Q_INVOKABLE bool addProduct(
        qint64 productId,
        const QString& productName,
        double unitPrice,
        int quantity = 1,
        int maxStock = 9999
    );
    
    /// Actualiza la cantidad de un item
    Q_INVOKABLE bool updateQuantity(int index, int newQuantity);
    
    /// Incrementa la cantidad de un item
    Q_INVOKABLE bool incrementQuantity(int index);
    
    /// Decrementa la cantidad de un item
    Q_INVOKABLE bool decrementQuantity(int index);
    
    /// Elimina un item del carrito
    Q_INVOKABLE void removeItem(int index);
    
    /// Limpia todo el carrito
    Q_INVOKABLE void clear();
    
    /// Obtiene un item por √≠ndice
    Q_INVOKABLE QVariantMap getItem(int index) const;
    
    /// Verifica si un producto ya est√° en el carrito
    Q_INVOKABLE bool containsProduct(qint64 productId) const;
    
    /// Obtiene el √≠ndice de un producto en el carrito
    Q_INVOKABLE int indexOfProduct(qint64 productId) const;
    
    /// Obtiene todos los items como lista
    [[nodiscard]] QList<CartItem> items() const { return m_items; }
    
signals:
    void countChanged();
    void cartChanged();
    void taxPercentChanged();
    void itemAdded(qint64 productId);
    void itemRemoved(qint64 productId);
    void itemUpdated(int index);
    
private:
    void recalculate();
    
    QList<CartItem> m_items;
    double m_taxPercent = Sales::Defaults::DEFAULT_TAX_PERCENT;
    double m_discountAmount = 0.0;
    
    // Valores calculados
    double m_subtotal = 0.0;
    double m_taxAmount = 0.0;
    double m_total = 0.0;
};

} // namespace Vento
```

---

## üìÑ src/features/sales/CartModel.cpp

```cpp
//==============================================================================
// CartModel.cpp
// Vento - Implementaci√≥n del modelo de carrito
//==============================================================================

#include "CartModel.hpp"

namespace Vento {

CartModel::CartModel(QObject* parent)
    : QAbstractListModel(parent)
{
}

//==============================================================================
// QAbstractListModel
//==============================================================================
int CartModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return static_cast<int>(m_items.size());
}

QVariant CartModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() < 0 || index.row() >= m_items.size()) {
        return {};
    }
    
    const CartItem& item = m_items.at(index.row());
    
    using namespace Sales::Roles;
    
    switch (role) {
        case ProductIdRole:
            return item.productId;
        case ProductNameRole:
            return item.productName;
        case UnitPriceRole:
            return item.unitPrice;
        case QuantityRole:
            return item.quantity;
        case SubtotalRole:
            return item.subtotal();
        case MaxStockRole:
            return item.maxStock;
        case FormattedUnitPriceRole:
            return QString::number(item.unitPrice, 'f', 2);
        case FormattedSubtotalRole:
            return QString::number(item.subtotal(), 'f', 2);
        default:
            return {};
    }
}

QHash<int, QByteArray> CartModel::roleNames() const {
    using namespace Sales::Roles;
    
    return {
        {ProductIdRole, "productId"},
        {ProductNameRole, "productName"},
        {UnitPriceRole, "unitPrice"},
        {QuantityRole, "quantity"},
        {SubtotalRole, "subtotal"},
        {MaxStockRole, "maxStock"},
        {FormattedUnitPriceRole, "formattedUnitPrice"},
        {FormattedSubtotalRole, "formattedSubtotal"}
    };
}

//==============================================================================
// Propiedades
//==============================================================================
int CartModel::count() const {
    return static_cast<int>(m_items.size());
}

int CartModel::totalItems() const {
    int total = 0;
    for (const auto& item : m_items) {
        total += item.quantity;
    }
    return total;
}

double CartModel::subtotal() const {
    return m_subtotal;
}

double CartModel::taxAmount() const {
    return m_taxAmount;
}

double CartModel::total() const {
    return m_total;
}

double CartModel::taxPercent() const {
    return m_taxPercent;
}

double CartModel::discountAmount() const {
    return m_discountAmount;
}

bool CartModel::isEmpty() const {
    return m_items.isEmpty();
}

void CartModel::setTaxPercent(double percent) {
    if (qAbs(m_taxPercent - percent) > 0.001) {
        m_taxPercent = percent;
        recalculate();
        emit taxPercentChanged();
    }
}

void CartModel::setDiscountAmount(double amount) {
    if (qAbs(m_discountAmount - amount) > 0.001) {
        m_discountAmount = std::max(0.0, amount);
        recalculate();
    }
}

//==============================================================================
// M√©todos Q_INVOKABLE
//==============================================================================
bool CartModel::addProduct(
    qint64 productId,
    const QString& productName,
    double unitPrice,
    int quantity,
    int maxStock
) {
    // Verificar si ya existe en el carrito
    int existingIndex = indexOfProduct(productId);
    
    if (existingIndex >= 0) {
        // Incrementar cantidad del item existente
        CartItem& existing = m_items[existingIndex];
        int newQuantity = existing.quantity + quantity;
        
        if (newQuantity > existing.maxStock) {
            return false; // No hay suficiente stock
        }
        
        existing.quantity = newQuantity;
        
        QModelIndex idx = createIndex(existingIndex, 0);
        emit dataChanged(idx, idx, {Sales::Roles::QuantityRole, Sales::Roles::SubtotalRole});
        emit itemUpdated(existingIndex);
    } else {
        // A√±adir nuevo item
        if (quantity > maxStock) {
            return false;
        }
        
        CartItem item;
        item.productId = productId;
        item.productName = productName;
        item.unitPrice = unitPrice;
        item.quantity = quantity;
        item.maxStock = maxStock;
        
        int newIndex = m_items.size();
        beginInsertRows(QModelIndex(), newIndex, newIndex);
        m_items.append(item);
        endInsertRows();
        
        emit countChanged();
        emit itemAdded(productId);
    }
    
    recalculate();
    return true;
}

bool CartModel::updateQuantity(int index, int newQuantity) {
    if (index < 0 || index >= m_items.size()) {
        return false;
    }
    
    CartItem& item = m_items[index];
    
    if (newQuantity <= 0) {
        removeItem(index);
        return true;
    }
    
    if (newQuantity > item.maxStock) {
        return false;
    }
    
    item.quantity = newQuantity;
    
    QModelIndex idx = createIndex(index, 0);
    emit dataChanged(idx, idx, {Sales::Roles::QuantityRole, Sales::Roles::SubtotalRole});
    emit itemUpdated(index);
    
    recalculate();
    return true;
}

bool CartModel::incrementQuantity(int index) {
    if (index < 0 || index >= m_items.size()) {
        return false;
    }
    
    return updateQuantity(index, m_items[index].quantity + 1);
}

bool CartModel::decrementQuantity(int index) {
    if (index < 0 || index >= m_items.size()) {
        return false;
    }
    
    return updateQuantity(index, m_items[index].quantity - 1);
}

void CartModel::removeItem(int index) {
    if (index < 0 || index >= m_items.size()) {
        return;
    }
    
    qint64 productId = m_items[index].productId;
    
    beginRemoveRows(QModelIndex(), index, index);
    m_items.removeAt(index);
    endRemoveRows();
    
    emit countChanged();
    emit itemRemoved(productId);
    
    recalculate();
}

void CartModel::clear() {
    if (m_items.isEmpty()) {
        return;
    }
    
    beginResetModel();
    m_items.clear();
    endResetModel();
    
    m_subtotal = 0;
    m_taxAmount = 0;
    m_total = 0;
    m_discountAmount = 0;
    
    emit countChanged();
    emit cartChanged();
}

QVariantMap CartModel::getItem(int index) const {
    if (index < 0 || index >= m_items.size()) {
        return {};
    }
    
    return m_items[index].toVariantMap();
}

bool CartModel::containsProduct(qint64 productId) const {
    return indexOfProduct(productId) >= 0;
}

int CartModel::indexOfProduct(qint64 productId) const {
    for (int i = 0; i < m_items.size(); ++i) {
        if (m_items[i].productId == productId) {
            return i;
        }
    }
    return -1;
}

//==============================================================================
// Helpers Privados
//==============================================================================
void CartModel::recalculate() {
    m_subtotal = 0.0;
    
    for (const auto& item : m_items) {
        m_subtotal += item.subtotal();
    }
    
    m_taxAmount = m_subtotal * (m_taxPercent / 100.0);
    m_total = m_subtotal + m_taxAmount - m_discountAmount;
    
    if (m_total < 0) {
        m_total = 0;
    }
    
    emit cartChanged();
}

} // namespace Vento
```

---

## üìÑ src/features/sales/SalesModel.hpp

```cpp
//==============================================================================
// SalesModel.hpp
// Vento - Modelo de historial de ventas para QML
//==============================================================================
#pragma once

#include <QAbstractListModel>
#include <QList>
#include <QDate>

#include "Sale.hpp"
#include "SalesTypes.hpp"
#include "SalesRepository.hpp"

namespace Vento {

class SalesModel : public QAbstractListModel {
    Q_OBJECT
    
    Q_PROPERTY(int count READ count NOTIFY countChanged)
    Q_PROPERTY(bool loading READ isLoading NOTIFY loadingChanged)
    Q_PROPERTY(double totalAmount READ totalAmount NOTIFY dataChanged)
    
public:
    explicit SalesModel(QObject* parent = nullptr);
    
    //==========================================================================
    // QAbstractListModel
    //==========================================================================
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role) const override;
    QHash<int, QByteArray> roleNames() const override;
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    [[nodiscard]] int count() const;
    [[nodiscard]] bool isLoading() const;
    [[nodiscard]] double totalAmount() const;
    
    //==========================================================================
    // M√©todos Q_INVOKABLE
    //==========================================================================
    
    Q_INVOKABLE void load(int limit = 100);
    Q_INVOKABLE void loadToday();
    Q_INVOKABLE void loadByDateRange(const QDate& start, const QDate& end);
    Q_INVOKABLE void loadByFilter(const QString& filter);
    Q_INVOKABLE QVariantMap get(int index) const;
    Q_INVOKABLE QVariantMap getById(qint64 id) const;
    Q_INVOKABLE QVariantList getItems(qint64 saleId) const;
    Q_INVOKABLE void refresh();
    
    //==========================================================================
    // M√©todos internos
    //==========================================================================
    void addSale(const Sale& sale);
    void setRepository(SalesRepository* repo);
    
signals:
    void countChanged();
    void loadingChanged();
    void dataChanged();
    
private:
    QList<Sale> m_sales;
    SalesRepository* m_repository = nullptr;
    bool m_loading = false;
};

} // namespace Vento
```

---

## üìÑ src/features/sales/SalesModel.cpp

```cpp
//==============================================================================
// SalesModel.cpp
// Vento - Implementaci√≥n del modelo de historial
//==============================================================================

#include "SalesModel.hpp"
#include "features/currency/CurrencyService.hpp"

namespace Vento {

SalesModel::SalesModel(QObject* parent)
    : QAbstractListModel(parent)
    , m_repository(new SalesRepository(this))
{
}

//==============================================================================
// QAbstractListModel
//==============================================================================
int SalesModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return static_cast<int>(m_sales.size());
}

QVariant SalesModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() < 0 || index.row() >= m_sales.size()) {
        return {};
    }
    
    const Sale& sale = m_sales.at(index.row());
    auto& currency = CurrencyService::instance();
    
    using namespace Sales::Roles;
    
    switch (role) {
        case IdRole:
            return sale.id;
        case SaleDateRole:
            return sale.saleDate;
        case SubtotalRole:
            return sale.subtotal;
        case TaxPercentRole:
            return sale.taxPercent;
        case TaxAmountRole:
            return sale.taxAmount;
        case DiscountAmountRole:
            return sale.discountAmount;
        case TotalRole:
            return sale.total;
        case ExchangeRateRole:
            return sale.exchangeRate;
        case PaymentMethodRole:
            return Sales::paymentToString(sale.paymentMethod);
        case PaymentMethodDisplayRole:
            return Sales::paymentDisplayName(sale.paymentMethod);
        case CustomerNameRole:
            return sale.customerName;
        case StatusRole:
            return Sales::statusToString(sale.status);
        case StatusDisplayRole:
            return Sales::statusDisplayName(sale.status);
        case NotesRole:
            return sale.notes;
        case ItemCountRole:
            return sale.itemCount();
        case FormattedTotalRole:
            return currency.formatLocal(sale.total);
        case FormattedDateRole:
            return sale.saleDate.toString("dd/MM/yyyy");
        case FormattedTimeRole:
            return sale.saleDate.toString("hh:mm");
        default:
            return {};
    }
}

QHash<int, QByteArray> SalesModel::roleNames() const {
    using namespace Sales::Roles;
    
    return {
        {IdRole, "id"},
        {SaleDateRole, "saleDate"},
        {SubtotalRole, "subtotal"},
        {TaxPercentRole, "taxPercent"},
        {TaxAmountRole, "taxAmount"},
        {DiscountAmountRole, "discountAmount"},
        {TotalRole, "total"},
        {ExchangeRateRole, "exchangeRate"},
        {PaymentMethodRole, "paymentMethod"},
        {PaymentMethodDisplayRole, "paymentMethodDisplay"},
        {CustomerNameRole, "customerName"},
        {StatusRole, "status"},
        {StatusDisplayRole, "statusDisplay"},
        {NotesRole, "notes"},
        {ItemCountRole, "itemCount"},
        {FormattedTotalRole, "formattedTotal"},
        {FormattedDateRole, "formattedDate"},
        {FormattedTimeRole, "formattedTime"}
    };
}

//==============================================================================
// Propiedades
//==============================================================================
int SalesModel::count() const {
    return static_cast<int>(m_sales.size());
}

bool SalesModel::isLoading() const {
    return m_loading;
}

double SalesModel::totalAmount() const {
    double total = 0.0;
    for (const auto& sale : m_sales) {
        if (sale.status == Sales::SaleStatus::Completed) {
            total += sale.total;
        }
    }
    return total;
}

//==============================================================================
// M√©todos Q_INVOKABLE
//==============================================================================
void SalesModel::load(int limit) {
    if (!m_repository) return;
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    m_sales = m_repository->findAll(Sales::SaleFilter::All, limit);
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
    emit dataChanged();
}

void SalesModel::loadToday() {
    if (!m_repository) return;
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    m_sales = m_repository->findToday();
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
    emit dataChanged();
}

void SalesModel::loadByDateRange(const QDate& start, const QDate& end) {
    if (!m_repository) return;
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    m_sales = m_repository->findByDateRange(start, end);
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
    emit dataChanged();
}

void SalesModel::loadByFilter(const QString& filter) {
    if (!m_repository) return;
    
    Sales::SaleFilter saleFilter = Sales::SaleFilter::All;
    
    if (filter == "today") saleFilter = Sales::SaleFilter::Today;
    else if (filter == "week") saleFilter = Sales::SaleFilter::ThisWeek;
    else if (filter == "month") saleFilter = Sales::SaleFilter::ThisMonth;
    else if (filter == "completed") saleFilter = Sales::SaleFilter::Completed;
    else if (filter == "cancelled") saleFilter = Sales::SaleFilter::Cancelled;
    
    m_loading = true;
    emit loadingChanged();
    
    beginResetModel();
    m_sales = m_repository->findAll(saleFilter);
    endResetModel();
    
    m_loading = false;
    emit loadingChanged();
    emit countChanged();
    emit dataChanged();
}

QVariantMap SalesModel::get(int index) const {
    if (index < 0 || index >= m_sales.size()) {
        return {};
    }
    return m_sales.at(index).toVariantMap();
}

QVariantMap SalesModel::getById(qint64 id) const {
    for (const auto& sale : m_sales) {
        if (sale.id == id) {
            return sale.toVariantMap();
        }
    }
    
    if (m_repository) {
        auto sale = m_repository->findById(id);
        if (sale) {
            return sale->toVariantMap();
        }
    }
    
    return {};
}

QVariantList SalesModel::getItems(qint64 saleId) const {
    if (!m_repository) return {};
    
    auto items = m_repository->getSaleItems(saleId);
    
    QVariantList result;
    for (const auto& item : items) {
        result.append(item.toVariantMap());
    }
    
    return result;
}

void SalesModel::refresh() {
    load();
}

void SalesModel::addSale(const Sale& sale) {
    beginInsertRows(QModelIndex(), 0, 0);
    m_sales.prepend(sale);
    endInsertRows();
    
    emit countChanged();
    emit dataChanged();
}

void SalesModel::setRepository(SalesRepository* repo) {
    m_repository = repo;
}

} // namespace Vento
```

---

## üìÑ src/features/sales/SalesService.hpp

```cpp
//==============================================================================
// SalesService.hpp
// Vento - Servicio principal de ventas (Controller)
//==============================================================================
#pragma once

#include <QObject>
#include <QQmlEngine>
#include <memory>

#include "Sale.hpp"
#include "SaleItem.hpp"
#include "SalesModel.hpp"
#include "CartModel.hpp"
#include "SalesRepository.hpp"
#include "SalesTypes.hpp"

namespace Vento {

class SalesService : public QObject {
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    
    //==========================================================================
    // Propiedades QML
    //==========================================================================
    
    /// Modelo del carrito de compras
    Q_PROPERTY(CartModel* cart READ cart CONSTANT)
    
    /// Modelo de historial de ventas
    Q_PROPERTY(SalesModel* salesHistory READ salesHistory CONSTANT)
    
    /// Estad√≠sticas de ventas
    Q_PROPERTY(QVariantMap statistics READ statistics NOTIFY statisticsChanged)
    
    /// Total de ventas del d√≠a
    Q_PROPERTY(double todayTotal READ todayTotal NOTIFY statisticsChanged)
    
    /// Total de ventas de la semana
    Q_PROPERTY(double weekTotal READ weekTotal NOTIFY statisticsChanged)
    
    /// Total de ventas del mes
    Q_PROPERTY(double monthTotal READ monthTotal NOTIFY statisticsChanged)
    
    /// N√∫mero de ventas del d√≠a
    Q_PROPERTY(int todayCount READ todayCount NOTIFY statisticsChanged)
    
public:
    //==========================================================================
    // Singleton
    //==========================================================================
    static SalesService& instance();
    static SalesService* create(QQmlEngine* engine, QJSEngine* scriptEngine);
    
    SalesService(const SalesService&) = delete;
    SalesService& operator=(const SalesService&) = delete;
    
    //==========================================================================
    // Inicializaci√≥n
    //==========================================================================
    void initialize();
    
    //==========================================================================
    // Propiedades
    //==========================================================================
    [[nodiscard]] CartModel* cart();
    [[nodiscard]] SalesModel* salesHistory();
    [[nodiscard]] QVariantMap statistics() const;
    [[nodiscard]] double todayTotal() const;
    [[nodiscard]] double weekTotal() const;
    [[nodiscard]] double monthTotal() const;
    [[nodiscard]] int todayCount() const;
    
    //==========================================================================
    // M√©todos Q_INVOKABLE - Carrito
    //==========================================================================
    
    /// A√±ade un producto al carrito
    Q_INVOKABLE bool addToCart(qint64 productId);
    
    /// A√±ade un producto al carrito con cantidad espec√≠fica
    Q_INVOKABLE bool addToCartWithQuantity(qint64 productId, int quantity);
    
    /// Limpia el carrito
    Q_INVOKABLE void clearCart();
    
    //==========================================================================
    // M√©todos Q_INVOKABLE - Ventas
    //==========================================================================
    
    /// Registra una venta simple (un producto, cantidad 1)
    /// @param productId ID del producto
    /// @param finalPrice Precio final de venta
    /// @return ID de la venta o -1 si falla
    Q_INVOKABLE qint64 registerSale(qint64 productId, double finalPrice);
    
    /// Registra una venta con cantidad
    Q_INVOKABLE qint64 registerSaleWithQuantity(
        qint64 productId, 
        double unitPrice, 
        int quantity
    );
    
    /// Procesa el carrito actual como venta
    /// @param paymentMethod M√©todo de pago ("cash", "card", etc.)
    /// @param customerName Nombre del cliente (opcional)
    /// @param discount Descuento a aplicar (opcional)
    /// @return ID de la venta o -1 si falla
    Q_INVOKABLE qint64 checkoutCart(
        const QString& paymentMethod = "cash",
        const QString& customerName = {},
        double discount = 0.0
    );
    
    /// Cancela una venta
    Q_INVOKABLE bool cancelSale(qint64 saleId);
    
    /// Obtiene una venta por ID
    Q_INVOKABLE QVariantMap getSale(qint64 saleId) const;
    
    /// Obtiene los items de una venta
    Q_INVOKABLE QVariantList getSaleItems(qint64 saleId) const;
    
    //==========================================================================
    // M√©todos Q_INVOKABLE - Estad√≠sticas
    //==========================================================================
    
    /// Refresca las estad√≠sticas
    Q_INVOKABLE void refreshStatistics();
    
    /// Obtiene productos m√°s vendidos
    Q_INVOKABLE QVariantList getTopProducts(int limit = 10);
    
    /// Obtiene ventas por m√©todo de pago
    Q_INVOKABLE QVariantMap getSalesByPaymentMethod();
    
    /// Formatea un monto para mostrar
    Q_INVOKABLE QString formatAmount(double amount) const;
    
signals:
    void statisticsChanged();
    
    /// Emitida cuando se registra una venta
    void saleCompleted(qint64 saleId, double total);
    
    /// Emitida cuando se cancela una venta
    void saleCancelled(qint64 saleId);
    
    /// Emitida cuando cambia el carrito
    void cartChanged();
    
    /// Emitida cuando hay un error
    void errorOccurred(const QString& error);
    
    /// Emitida cuando hay stock insuficiente
    void insufficientStock(qint64 productId, int available, int requested);
    
private:
    //==========================================================================
    // Constructor privado (Singleton)
    //==========================================================================
    explicit SalesService(QObject* parent = nullptr);
    ~SalesService() override = default;
    
    //==========================================================================
    // Helpers
    //==========================================================================
    void connectSignals();
    void updateStatistics();
    
    //==========================================================================
    // Miembros
    //==========================================================================
    std::unique_ptr<CartModel> m_cartModel;
    std::unique_ptr<SalesModel> m_salesModel;
    std::unique_ptr<SalesRepository> m_repository;
    
    mutable QVariantMap m_cachedStatistics;
    mutable bool m_statisticsDirty = true;
    
    bool m_initialized = false;
};

} // namespace Vento
```

---

## üìÑ src/features/sales/SalesService.cpp

```cpp
//==============================================================================
// SalesService.cpp
// Vento - Implementaci√≥n del servicio de ventas
//==============================================================================

#include "SalesService.hpp"
#include "features/currency/CurrencyService.hpp"
#include "features/inventory/InventoryService.hpp"
#include "core/logger/Logger.hpp"
#include "core/utils/EventBus.hpp"

namespace Vento {

//==============================================================================
// Singleton
//==============================================================================
SalesService& SalesService::instance() {
    static SalesService instance;
    return instance;
}

SalesService* SalesService::create(QQmlEngine* engine, QJSEngine* scriptEngine) {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)
    
    auto* instance = &SalesService::instance();
    QJSEngine::setObjectOwnership(instance, QJSEngine::CppOwnership);
    return instance;
}

//==============================================================================
// Constructor
//==============================================================================
SalesService::SalesService(QObject* parent)
    : QObject(parent)
    , m_cartModel(std::make_unique<CartModel>(this))
    , m_salesModel(std::make_unique<SalesModel>(this))
    , m_repository(std::make_unique<SalesRepository>(this))
{
    m_salesModel->setRepository(m_repository.get());
    Logger::instance().debug("SalesService creado", "Sales");
}

//==============================================================================
// Inicializaci√≥n
//==============================================================================
void SalesService::initialize() {
    if (m_initialized) {
        Logger::instance().warning("SalesService ya inicializado", "Sales");
        return;
    }
    
    Logger::instance().info("Inicializando SalesService...", "Sales");
    
    connectSignals();
    m_salesModel->loadToday();
    updateStatistics();
    
    m_initialized = true;
    
    Logger::instance().info(
        QString("‚úì SalesService inicializado - Ventas hoy: %1")
            .arg(todayCount()),
        "Sales"
    );
}

void SalesService::connectSignals() {
    // Conectar cambios del carrito
    connect(m_cartModel.get(), &CartModel::cartChanged,
            this, &SalesService::cartChanged);
    
    // Escuchar cambios de inventario para refrescar estad√≠sticas
    connect(&InventoryService::instance(), &InventoryService::productUpdated,
            this, [this]() { m_statisticsDirty = true; });
}

//==============================================================================
// Propiedades
//==============================================================================
CartModel* SalesService::cart() {
    return m_cartModel.get();
}

SalesModel* SalesService::salesHistory() {
    return m_salesModel.get();
}

QVariantMap SalesService::statistics() const {
    if (m_statisticsDirty) {
        m_cachedStatistics = m_repository->getStatistics();
        m_statisticsDirty = false;
    }
    return m_cachedStatistics;
}

double SalesService::todayTotal() const {
    return m_repository->getTodayTotal();
}

double SalesService::weekTotal() const {
    return m_repository->getWeekTotal();
}

double SalesService::monthTotal() const {
    return m_repository->getMonthTotal();
}

int SalesService::todayCount() const {
    return m_repository->count(Sales::SaleFilter::Today);
}

//==============================================================================
// Carrito
//==============================================================================
bool SalesService::addToCart(qint64 productId) {
    return addToCartWithQuantity(productId, 1);
}

bool SalesService::addToCartWithQuantity(qint64 productId, int quantity) {
    // Obtener informaci√≥n del producto
    auto productData = InventoryService::instance().getProduct(productId);
    
    if (productData.isEmpty()) {
        emit errorOccurred(tr("Producto no encontrado"));
        return false;
    }
    
    QString productName = productData["name"].toString();
    double salePrice = productData["salePrice"].toDouble();
    int stockQuantity = productData["stockQuantity"].toInt();
    
    // Verificar stock
    int currentInCart = 0;
    int cartIndex = m_cartModel->indexOfProduct(productId);
    if (cartIndex >= 0) {
        currentInCart = m_cartModel->getItem(cartIndex)["quantity"].toInt();
    }
    
    if (currentInCart + quantity > stockQuantity) {
        emit insufficientStock(productId, stockQuantity, currentInCart + quantity);
        emit errorOccurred(
            tr("Stock insuficiente. Disponible: %1").arg(stockQuantity - currentInCart)
        );
        return false;
    }
    
    // A√±adir al carrito
    bool success = m_cartModel->addProduct(
        productId,
        productName,
        salePrice,
        quantity,
        stockQuantity
    );
    
    if (success) {
        Logger::instance().debug(
            QString("Producto a√±adido al carrito: %1 x%2").arg(productName).arg(quantity),
            "Sales"
        );
    }
    
    return success;
}

void SalesService::clearCart() {
    m_cartModel->clear();
    Logger::instance().debug("Carrito limpiado", "Sales");
}

//==============================================================================
// Registro de Ventas
//==============================================================================
qint64 SalesService::registerSale(qint64 productId, double finalPrice) {
    return registerSaleWithQuantity(productId, finalPrice, 1);
}

qint64 SalesService::registerSaleWithQuantity(
    qint64 productId, 
    double unitPrice, 
    int quantity
) {
    // Obtener informaci√≥n del producto
    auto productData = InventoryService::instance().getProduct(productId);
    
    if (productData.isEmpty()) {
        emit errorOccurred(tr("Producto no encontrado"));
        return -1;
    }
    
    QString productName = productData["name"].toString();
    int stockQuantity = productData["stockQuantity"].toInt();
    
    // Verificar stock
    if (stockQuantity < quantity) {
        emit insufficientStock(productId, stockQuantity, quantity);
        emit errorOccurred(
            tr("Stock insuficiente. Disponible: %1").arg(stockQuantity)
        );
        return -1;
    }
    
    // Obtener tasa de cambio actual
    double exchangeRate = CurrencyService::instance().exchangeRate();
    
    // Registrar la venta
    auto result = m_repository->registerQuickSale(
        productId,
        productName,
        unitPrice,
        quantity,
        exchangeRate,
        Sales::PaymentMethod::Cash
    );
    
    if (result) {
        // Refrescar el inventario
        InventoryService::instance().refresh();
        
        // Refrescar el historial de ventas
        m_salesModel->loadToday();
        
        // Actualizar estad√≠sticas
        m_statisticsDirty = true;
        emit statisticsChanged();
        
        // Emitir se√±al de venta completada
        emit saleCompleted(result.saleId, result.total);
        
        // Publicar evento
        EventBus::instance().publish(
            Events::SALE_COMPLETED,
            QVariant::fromValue(result.saleId)
        );
        
        Logger::instance().info(
            QString("üí∞ Venta r√°pida completada: #%1 - %2 x%3 = %4")
                .arg(result.saleId)
                .arg(productName)
                .arg(quantity)
                .arg(formatAmount(result.total)),
            "Sales"
        );
        
        return result.saleId;
    }
    
    emit errorOccurred(result.errorMessage);
    return -1;
}

qint64 SalesService::checkoutCart(
    const QString& paymentMethod,
    const QString& customerName,
    double discount
) {
    if (m_cartModel->isEmpty()) {
        emit errorOccurred(tr("El carrito est√° vac√≠o"));
        return -1;
    }
    
    // Crear la venta
    Sale sale;
    sale.saleDate = QDateTime::currentDateTime();
    sale.exchangeRate = CurrencyService::instance().exchangeRate();
    sale.paymentMethod = Sales::stringToPayment(paymentMethod);
    sale.customerName = customerName;
    sale.discountAmount = discount;
    sale.taxPercent = m_cartModel->taxPercent();
    sale.status = Sales::SaleStatus::Completed;
    
    // Convertir items del carrito a items de venta
    for (const auto& cartItem : m_cartModel->items()) {
        SaleItem saleItem;
        saleItem.productId = cartItem.productId;
        saleItem.productName = cartItem.productName;
        saleItem.unitPrice = cartItem.unitPrice;
        saleItem.quantity = cartItem.quantity;
        saleItem.calculateSubtotal();
        
        sale.items.append(saleItem);
    }
    
    sale.calculateAll();
    
    // Registrar la venta
    qint64 saleId = m_repository->createSale(sale);
    
    if (saleId > 0) {
        sale.id = saleId;
        
        // Limpiar carrito
        m_cartModel->clear();
        
        // Refrescar inventario (el stock ya fue descontado en createSale)
        InventoryService::instance().refresh();
        
        // A√±adir al historial
        m_salesModel->addSale(sale);
        
        // Actualizar estad√≠sticas
        m_statisticsDirty = true;
        emit statisticsChanged();
        
        // Emitir se√±ales
        emit saleCompleted(saleId, sale.total);
        
        EventBus::instance().publish(
            Events::SALE_COMPLETED,
            QVariant::fromValue(saleId)
        );
        
        Logger::instance().info(
            QString("üí∞ Venta completada: #%1 - Total: %2 (%3 items)")
                .arg(saleId)
                .arg(formatAmount(sale.total))
                .arg(sale.items.size()),
            "Sales"
        );
        
        return saleId;
    }
    
    emit errorOccurred(tr("Error al procesar la venta"));
    return -1;
}

bool SalesService::cancelSale(qint64 saleId) {
    bool success = m_repository->cancelSale(saleId);
    
    if (success) {
        // Refrescar inventario (stock restaurado)
        InventoryService::instance().refresh();
        
        // Refrescar historial
        m_salesModel->refresh();
        
        // Actualizar estad√≠sticas
        m_statisticsDirty = true;
        emit statisticsChanged();
        
        emit saleCancelled(saleId);
        
        Logger::instance().info(
            QString("Venta #%1 cancelada").arg(saleId),
            "Sales"
        );
    } else {
        emit errorOccurred(tr("No se pudo cancelar la venta"));
    }
    
    return success;
}

QVariantMap SalesService::getSale(qint64 saleId) const {
    auto sale = m_repository->findById(saleId);
    if (sale) {
        return sale->toVariantMap();
    }
    return {};
}

QVariantList SalesService::getSaleItems(qint64 saleId) const {
    auto items = m_repository->getSaleItems(saleId);
    
    QVariantList result;
    for (const auto& item : items) {
        result.append(item.toVariantMap());
    }
    
    return result;
}

//==============================================================================
// Estad√≠sticas
//==============================================================================
void SalesService::refreshStatistics() {
    m_statisticsDirty = true;
    emit statisticsChanged();
}

QVariantList SalesService::getTopProducts(int limit) {
    return m_repository->getTopProducts(limit);
}

QVariantMap SalesService::getSalesByPaymentMethod() {
    return m_repository->getSalesByPaymentMethod();
}

QString SalesService::formatAmount(double amount) const {
    return CurrencyService::instance().formatLocal(amount);
}

//==============================================================================
// Helpers
//==============================================================================
void SalesService::updateStatistics() {
    m_statisticsDirty = true;
    emit statisticsChanged();
}

} // namespace Vento
```

---

## üìÑ src/features/sales/CMakeLists.txt

```cmake
#===============================================================================
# src/features/sales/CMakeLists.txt
# Vento - Feature Sales
#===============================================================================

set(SALES_SOURCES
    SalesRepository.cpp
    SalesModel.cpp
    CartModel.cpp
    SalesService.cpp
)

set(SALES_HEADERS
    SalesTypes.hpp
    Sale.hpp
    SaleItem.hpp
    SalesRepository.hpp
    SalesModel.hpp
    CartModel.hpp
    SalesService.hpp
)

#===============================================================================
# Biblioteca
#===============================================================================
add_library(VentoSales STATIC
    ${SALES_SOURCES}
    ${SALES_HEADERS}
)

add_library(Vento::Sales ALIAS VentoSales)

#===============================================================================
# Configuraci√≥n
#===============================================================================
target_include_directories(VentoSales
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_CURRENT_SOURCE_DIR}/..
)

target_link_libraries(VentoSales
    PUBLIC
        Qt6::Core
        Qt6::Qml
        Vento::Core
        Vento::Currency
        Vento::Inventory
)

target_compile_features(VentoSales PUBLIC cxx_std_20)
```

---

## üìÑ Vista QML para Ventas - src/ui/qml/views/SalesView.qml

```qml
//==============================================================================
// SalesView.qml
// Vento - Punto de Venta (POS)
//==============================================================================

import QtQuick
import QtQuick.Controls
import QtQuick.Controls.Material
import QtQuick.Layouts

import Vento.Sales 1.0
import Vento.Inventory 1.0
import Vento.Currency 1.0

Item {
    id: salesView
    
    readonly property var appColors: ({
        primary: "#0078D4",
        success: "#107C10",
        warning: "#FF8C00",
        danger: "#D13438",
        surface: "#FFFFFF",
        background: "#F3F3F3"
    })
    
    RowLayout {
        anchors.fill: parent
        anchors.margins: 16
        spacing: 16
        
        //======================================================================
        // Panel izquierdo: Productos
        //======================================================================
        ColumnLayout {
            Layout.fillWidth: true
            Layout.fillHeight: true
            Layout.preferredWidth: 2
            spacing: 12
            
            // B√∫squeda de productos
            Pane {
                Layout.fillWidth: true
                Material.elevation: 1
                
                RowLayout {
                    anchors.fill: parent
                    spacing: 12
                    
                    TextField {
                        id: productSearch
                        Layout.fillWidth: true
                        placeholderText: "üîç Buscar producto o escanear c√≥digo..."
                        
                        onTextChanged: {
                            if (text.length >= 2) {
                                searchTimer.restart()
                            }
                        }
                        
                        onAccepted: {
                            // Si es un c√≥digo de barras, buscar directamente
                            let product = InventoryService.findByBarcode(text)
                            if (product.id) {
                                SalesService.addToCart(product.id)
                                text = ""
                            }
                        }
                        
                        Timer {
                            id: searchTimer
                            interval: 300
                            onTriggered: {
                                InventoryService.products.search(productSearch.text)
                            }
                        }
                    }
                    
                    Button {
                        text: "Limpiar"
                        onClicked: {
                            productSearch.text = ""
                            InventoryService.products.load()
                        }
                    }
                }
            }
            
            // Grid de productos
            Pane {
                Layout.fillWidth: true
                Layout.fillHeight: true
                Material.elevation: 1
                padding: 8
                
                GridView {
                    id: productGrid
                    anchors.fill: parent
                    clip: true
                    
                    cellWidth: 160
                    cellHeight: 140
                    
                    model: InventoryService.products
                    
                    delegate: ItemDelegate {
                        width: productGrid.cellWidth - 8
                        height: productGrid.cellHeight - 8
                        
                        enabled: model.stockQuantity > 0
                        opacity: model.stockQuantity > 0 ? 1.0 : 0.5
                        
                        background: Rectangle {
                            radius: 8
                            color: parent.hovered ? "#E3F2FD" : appColors.surface
                            border.color: parent.hovered ? appColors.primary : "#E0E0E0"
                            border.width: 1
                            
                            Rectangle {
                                anchors.top: parent.top
                                anchors.left: parent.left
                                anchors.right: parent.right
                                height: 4
                                radius: 8
                                color: {
                                    if (model.stockStatus === "out") return appColors.danger
                                    if (model.stockStatus === "low") return appColors.warning
                                    return appColors.success
                                }
                            }
                        }
                        
                        contentItem: ColumnLayout {
                            spacing: 4
                            
                            Label {
                                text: model.name
                                font.weight: Font.Medium
                                elide: Text.ElideRight
                                Layout.fillWidth: true
                                horizontalAlignment: Text.AlignHCenter
                            }
                            
                            Label {
                                text: model.category || ""
                                font.pixelSize: 11
                                color: "#666"
                                Layout.alignment: Qt.AlignHCenter
                            }
                            
                            Item { Layout.fillHeight: true }
                            
                            Label {
                                text: model.formattedSalePrice
                                font.pixelSize: 18
                                font.weight: Font.Bold
                                color: appColors.primary
                                Layout.alignment: Qt.AlignHCenter
                            }
                            
                            Label {
                                text: "Stock: " + model.stockQuantity
                                font.pixelSize: 11
                                color: model.stockStatus === "ok" ? "#666" : appColors.warning
                                Layout.alignment: Qt.AlignHCenter
                            }
                        }
                        
                        onClicked: {
                            if (model.stockQuantity > 0) {
                                SalesService.addToCart(model.id)
                            }
                        }
                    }
                }
            }
        }
        
        //======================================================================
        // Panel derecho: Carrito
        //======================================================================
        ColumnLayout {
            Layout.preferredWidth: 400
            Layout.fillHeight: true
            spacing: 12
            
            // Encabezado del carrito
            Pane {
                Layout.fillWidth: true
                Material.elevation: 2
                Material.background: appColors.primary
                
                RowLayout {
                    anchors.fill: parent
                    
                    Label {
                        text: "üõí Carrito"
                        font.pixelSize: 18
                        font.weight: Font.Bold
                        color: "white"
                    }
                    
                    Item { Layout.fillWidth: true }
                    
                    Label {
                        text: SalesService.cart.totalItems + " items"
                        color: "white"
                        opacity: 0.9
                    }
                    
                    ToolButton {
                        icon.source: "qrc:/icons/delete.svg"
                        icon.color: "white"
                        
                        onClicked: SalesService.clearCart()
                        
                        ToolTip.visible: hovered
                        ToolTip.text: "Vaciar carrito"
                    }
                }
            }
            
            // Lista de items
            Pane {
                Layout.fillWidth: true
                Layout.fillHeight: true
                Material.elevation: 1
                padding: 0
                
                ListView {
                    id: cartList
                    anchors.fill: parent
                    anchors.margins: 1
                    clip: true
                    
                    model: SalesService.cart
                    
                    delegate: Rectangle {
                        width: cartList.width
                        height: 70
                        color: index % 2 === 0 ? "white" : "#FAFAFA"
                        
                        RowLayout {
                            anchors.fill: parent
                            anchors.margins: 12
                            spacing: 8
                            
                            ColumnLayout {
                                Layout.fillWidth: true
                                spacing: 2
                                
                                Label {
                                    text: model.productName
                                    font.weight: Font.Medium
                                    elide: Text.ElideRight
                                    Layout.fillWidth: true
                                }
                                
                                Label {
                                    text: CurrencyService.formatLocal(model.unitPrice) + " c/u"
                                    font.pixelSize: 12
                                    color: "#666"
                                }
                            }
                            
                            // Controles de cantidad
                            Row {
                                spacing: 4
                                
                                RoundButton {
                                    width: 32
                                    height: 32
                                    text: "-"
                                    font.pixelSize: 16
                                    
                                    onClicked: SalesService.cart.decrementQuantity(index)
                                }
                                
                                Label {
                                    width: 40
                                    text: model.quantity
                                    font.weight: Font.Bold
                                    horizontalAlignment: Text.AlignHCenter
                                    anchors.verticalCenter: parent.verticalCenter
                                }
                                
                                RoundButton {
                                    width: 32
                                    height: 32
                                    text: "+"
                                    font.pixelSize: 16
                                    enabled: model.quantity < model.maxStock
                                    
                                    onClicked: SalesService.cart.incrementQuantity(index)
                                }
                            }
                            
                            // Subtotal
                            Label {
                                text: CurrencyService.formatLocal(model.subtotal)
                                font.weight: Font.Bold
                                color: appColors.primary
                                Layout.preferredWidth: 100
                                horizontalAlignment: Text.AlignRight
                            }
                            
                            // Eliminar
                            ToolButton {
                                icon.source: "qrc:/icons/close.svg"
                                icon.width: 16
                                icon.height: 16
                                
                                onClicked: SalesService.cart.removeItem(index)
                            }
                        }
                    }
                    
                    // Empty state
                    Label {
                        anchors.centerIn: parent
                        text: "üõí Carrito vac√≠o\nHaz clic en un producto para a√±adirlo"
                        horizontalAlignment: Text.AlignHCenter
                        color: "#888"
                        visible: cartList.count === 0
                    }
                }
            }
            
            // Totales
            Pane {
                Layout.fillWidth: true
                Material.elevation: 1
                
                ColumnLayout {
                    anchors.fill: parent
                    spacing: 8
                    
                    RowLayout {
                        Layout.fillWidth: true
                        Label { text: "Subtotal:"; color: "#666" }
                        Item { Layout.fillWidth: true }
                        Label { 
                            text: CurrencyService.formatLocal(SalesService.cart.subtotal)
                            font.weight: Font.Medium
                        }
                    }
                    
                    RowLayout {
                        Layout.fillWidth: true
                        Label { text: "IVA (" + SalesService.cart.taxPercent + "%):"; color: "#666" }
                        Item { Layout.fillWidth: true }
                        Label { 
                            text: CurrencyService.formatLocal(SalesService.cart.taxAmount)
                        }
                    }
                    
                    Rectangle {
                        Layout.fillWidth: true
                        height: 1
                        color: "#E0E0E0"
                    }
                    
                    RowLayout {
                        Layout.fillWidth: true
                        Label { 
                            text: "TOTAL:"
                            font.pixelSize: 18
                            font.weight: Font.Bold
                        }
                        Item { Layout.fillWidth: true }
                        Label { 
                            text: CurrencyService.formatLocal(SalesService.cart.total)
                            font.pixelSize: 24
                            font.weight: Font.Bold
                            color: appColors.primary
                        }
                    }
                }
            }
            
            // M√©todos de pago
            Pane {
                Layout.fillWidth: true
                Material.elevation: 1
                
                RowLayout {
                    anchors.fill: parent
                    spacing: 8
                    
                    Repeater {
                        model: [
                            { icon: "üíµ", text: "Efectivo", method: "cash" },
                            { icon: "üí≥", text: "Tarjeta", method: "card" },
                            { icon: "üì±", text: "M√≥vil", method: "mobile" }
                        ]
                        
                        delegate: Button {
                            Layout.fillWidth: true
                            text: modelData.icon + " " + modelData.text
                            enabled: !SalesService.cart.isEmpty
                            
                            onClicked: {
                                confirmSaleDialog.paymentMethod = modelData.method
                                confirmSaleDialog.open()
                            }
                        }
                    }
                }
            }
        }
    }
    
    //==========================================================================
    // Di√°logo de confirmaci√≥n de venta
    //==========================================================================
    Dialog {
        id: confirmSaleDialog
        title: "Confirmar Venta"
        modal: true
        anchors.centerIn: parent
        width: 400
        
        property string paymentMethod: "cash"
        
        standardButtons: Dialog.Ok | Dialog.Cancel
        
        onAccepted: {
            let saleId = SalesService.checkoutCart(
                paymentMethod,
                customerNameField.text,
                0
            )
            
            if (saleId > 0) {
                saleSuccessDialog.saleId = saleId
                saleSuccessDialog.total = SalesService.cart.total
                saleSuccessDialog.open()
            }
            
            customerNameField.text = ""
        }
        
        ColumnLayout {
            anchors.fill: parent
            spacing: 16
            
            Label {
                text: "Total a pagar:"
                font.pixelSize: 16
            }
            
            Label {
                text: CurrencyService.formatLocal(SalesService.cart.total)
                font.pixelSize: 32
                font.weight: Font.Bold
                color: appColors.primary
                Layout.alignment: Qt.AlignHCenter
            }
            
            TextField {
                id: customerNameField
                Layout.fillWidth: true
                placeholderText: "Nombre del cliente (opcional)"
            }
        }
    }
    
    //==========================================================================
    // Di√°logo de venta exitosa
    //==========================================================================
    Dialog {
        id: saleSuccessDialog
        title: "‚úì Venta Completada"
        modal: true
        anchors.centerIn: parent
        
        property int saleId: 0
        property double total: 0
        
        standardButtons: Dialog.Ok
        
        ColumnLayout {
            spacing: 16
            
            Label {
                text: "üéâ"
                font.pixelSize: 48
                Layout.alignment: Qt.AlignHCenter
            }
            
            Label {
                text: "Venta #" + saleSuccessDialog.saleId
                font.pixelSize: 18
                font.weight: Font.Bold
                Layout.alignment: Qt.AlignHCenter
            }
            
            Label {
                text: CurrencyService.formatLocal(saleSuccessDialog.total)
                font.pixelSize: 24
                color: appColors.success
                Layout.alignment: Qt.AlignHCenter
            }
        }
    }
    
    //==========================================================================
    // Conexiones
    //==========================================================================
    Connections {
        target: SalesService
        
        function onSaleCompleted(saleId, total) {
            console.log("Venta completada:", saleId, "Total:", total)
        }
        
        function onErrorOccurred(error) {
            console.error("Error en venta:", error)
            // Aqu√≠ podr√≠as mostrar un toast/snackbar
        }
        
        function onInsufficientStock(productId, available, requested) {
            console.warn("Stock insuficiente:", productId, "Disponible:", available)
        }
    }
}
```

---

## üìä Diagrama del Flujo de Venta

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         FLUJO DE REGISTRO DE VENTA                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                        ‚îÇ
‚îÇ  ‚îÇ  Usuario a√±ade  ‚îÇ                                                        ‚îÇ
‚îÇ  ‚îÇ  productos al   ‚îÇ                                                        ‚îÇ
‚îÇ  ‚îÇ    carrito      ‚îÇ                                                        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                        ‚îÇ
‚îÇ           ‚îÇ                                                                  ‚îÇ
‚îÇ           ‚ñº                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                      SalesService.addToCart()                        ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  1. Obtener datos del producto (InventoryService)           ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  2. Verificar stock disponible                              ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  3. A√±adir/actualizar en CartModel                         ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                   ‚îÇ          ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ           ‚îÇ  Usuario confirma venta                                          ‚îÇ
‚îÇ           ‚ñº                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                    SalesService.checkoutCart()                       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  1. Crear objeto Sale con items del carrito                 ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  2. Obtener exchangeRate de CurrencyService                 ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  3. Calcular totales (subtotal, tax, total)                ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                   ‚îÇ          ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ           ‚ñº                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                   SalesRepository.createSale()                       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë                     TRANSACCI√ìN SQL                            ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë  1. INSERT INTO sales (...)                                   ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë     ‚Üí Guarda encabezado de venta                              ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë                                                                ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë  2. Por cada item:                                            ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë     a) INSERT INTO sale_items (...)                           ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë     b) UPDATE products SET stock_quantity = stock - qty      ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë                                                                ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïë  3. COMMIT                                                    ‚ïë ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                   ‚îÇ          ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ           ‚îÇ  Venta exitosa                                                   ‚îÇ
‚îÇ           ‚ñº                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ                      Post-procesamiento                              ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  1. Limpiar carrito                                         ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  2. InventoryService.refresh() ‚Üí Actualizar UI productos   ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  3. SalesModel.addSale() ‚Üí Actualizar historial             ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  4. emit saleCompleted(id, total)                           ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  5. EventBus.publish("sale.completed")                      ‚îÇ   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ Resumen de lo Implementado

| Componente | Responsabilidad | Patr√≥n |
|------------|-----------------|--------|
| `Sale.hpp` / `SaleItem.hpp` | Estructuras de datos | Value Object |
| `CartModel` | Carrito de compras | Model (QAbstractListModel) |
| `SalesModel` | Historial de ventas | Model |
| `SalesRepository` | Persistencia SQL | Repository |
| `SalesService` | L√≥gica + Controller | Facade, Singleton |
| Transacci√≥n SQL | Atomicidad venta+stock | Transaction Pattern |

---

## üîë Puntos Clave

1. **Transacci√≥n at√≥mica**: `createSale()` usa una transacci√≥n que:
   - Inserta la venta
   - Inserta los items
   - Descuenta el stock
   - Si algo falla, hace rollback

2. **Snapshot de producto**: Se guarda `product_name` y `unit_price` en `sale_items` para mantener el hist√≥rico aunque el producto cambie.

3. **Tasa de cambio hist√≥rica**: Cada venta guarda `exchange_rate` del momento para reportes precisos.

4. **Stock en tiempo real**: Verificaci√≥n de stock antes de a√±adir al carrito y al confirmar venta.

---

¬øContinuamos con la implementaci√≥n de **Reporting** (generaci√≥n de reportes y estad√≠sticas)? üìä
