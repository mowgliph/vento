隆Hola! Qu茅 excelente proyecto. El "Vibe Coding" (programar fluyendo con la IA como motor principal) es ideal para este tipo de herramientas: necesidades claras, l贸gica de negocio directa y requerimientos de calidad t茅cnica (SOLID, C++).

Para lograr esto en C++ y que se vea moderno (estilo Windows 11) sin volverte loco con c贸digo visual antiguo, la mejor opci贸n tecnol贸gica es **C++ para el backend** y **Qt Quick (QML)** para la interfaz. QML permite interfaces fluidas, modernas y aceleradas por hardware muy f谩cilmente, mientras C++ maneja la l贸gica pesada y la base de datos.

Aqu铆 tienes tu **Plan Maestro** y luego la **Lista de Prompts** para que "vibe codes" esta aplicaci贸n.

---

# Parte 2: Los Prompts de Ingenier铆a (Vibe Coding) 

A continuaci贸n, te presento la secuencia de prompts. Copia y pega estos prompts uno por uno en tu LLM favorito (Claude 3.5 Sonnet, GPT-4o o DeepSeek R1).

**Nota importante:** No intentes generar todo de golpe. El secreto del vibe coding es la iteraci贸n controlada.

### Prompt 1: Configuraci贸n del Entorno y "Scaffolding"

Este prompt sienta las bases s贸lidas y el sistema de construcci贸n.

> **Prompt:**
> Act煤a como un experto en C++20 y Qt 6. Vamos a crear una aplicaci贸n de escritorio llamada "Vento".
> **Objetivo:** Crear la estructura base del proyecto usando CMake y una arquitectura "Feature-Based".
> **Requisitos T茅cnicos:**
> 1. Usa CMake como sistema de construcci贸n.
> 2. Estructura de carpetas: `src/core`, `src/features/currency`, `src/features/inventory`, `src/features/sales`, `src/ui`.
> 3. Configura el archivo `CMakeLists.txt` principal para incluir Qt6 (Core, Gui, Qml, Quick, Sql).
> 4. Crea un `main.cpp` simple que cargue un archivo `Main.qml` (con una ventana vac铆a por ahora).
> 5. Configura el estilo de la aplicaci贸n en el main para que use "Material" o "Fusion" para un look moderno.
> 
> 
> Por favor, entr茅game el script de bash/powershell para crear las carpetas y el c贸digo del `CMakeLists.txt` y `main.cpp`.

### Prompt 2: El N煤cleo de la Base de Datos (Core)

Aqu铆 creamos la conexi贸n a SQLite siguiendo el principio de Responsabilidad nica.

> **Prompt:**
> Excelente. Ahora implementemos la capa de persistencia en `src/core/database`.
> **Tarea:**
> Crea una clase `DatabaseManager` que siga el patr贸n Singleton (o un Service Locator simple) para gestionar la conexi贸n a SQLite.
> **Requisitos SOLID:**
> 1. La clase debe encargarse de abrir la conexi贸n y verificar que las tablas existan al inicio.
> 2. Implementa un m茅todo `initializeTables()` que ejecute el SQL de creaci贸n si no existen.
> 3. **Tablas necesarias:**
> * `settings`: Clave (TEXT), Valor (TEXT) -> Aqu铆 guardaremos el precio del d贸lar.
> * `products`: id, name, description, cost_usd, cost_mn, margin_percent, sale_price.
> * `sales`: id, product_id, sale_price, sale_date, quantity.
> 
> 
> 4. Usa sentencias preparadas ( `QSqlQuery` ) para seguridad.
> 
> 
> Dame el c贸digo de `DatabaseManager.h` y `DatabaseManager.cpp`.

### Prompt 3: Feature "Currency" (El D贸lar)

Esta es la base del c谩lculo.

> **Prompt:**
> Vamos con la primera Feature: **Currency** (`src/features/currency`).
> **L贸gica de Negocio:**
> Necesitamos gestionar el precio del d贸lar.
> **Implementaci贸n:**
> 1. Crea una clase `CurrencyService` (expuesta a QML) que permita:
> * `setExchangeRate(double rate)`: Guarda en la BD y emite una se帽al de cambio.
> * `getExchangeRate()`: Recupera el valor.
> 
> 
> 2. Esta clase debe heredar de `QObject` para usar el sistema de Signals/Slots de Qt.
> 3. Define una se帽al `exchangeRateChanged(double newRate)` que usaremos m谩s adelante para notificar a los productos.
> 
> 
> Genera el c贸digo C++ necesario.

### Prompt 4: Feature "Inventory" (Productos)

Aqu铆 est谩 la l贸gica compleja de precios.

> **Prompt:**
> Ahora la Feature m谩s importante: **Inventory** (`src/features/inventory`).
> **Requerimientos:**
> 1. Crea un modelo `ProductModel` que herede de `QAbstractListModel` para poder mostrarlo en una lista en la UI de QML eficientemente.
> 2. Implementa funciones para CRUD: `addProduct`, `updateProduct`, `deleteProduct`.
> 3. **L贸gica de Precios Autom谩tica:**
> * Cuando se a帽ade/edita un producto, el usuario ingresa `Costo USD` y `Margen`.
> * El sistema debe calcular autom谩ticamente:
> * `Precio Venta = (Costo USD * Tasa de Cambio) * (1 + Margen/100)`.
> 
> 
> * *Nota:* Necesitamos inyectar o conectar el `CurrencyService` aqu铆. Cuando la se帽al `exchangeRateChanged` se dispare, este modelo debe recalcular el `Precio Venta` de TODOS los productos y actualizar la base de datos y la vista.
> 
> 
> 
> 
> Escribe el c贸digo C++ cuidando la eficiencia (usa transacciones SQL si vas a actualizar muchos precios a la vez).

### Prompt 5: Feature "Sales" (Ventas)

Registro r谩pido.

> **Prompt:**
> Implementemos la Feature: **Sales** (`src/features/sales`).
> **Requerimientos:**
> 1. Crea una clase `SalesController` expuesta a QML.
> 2. M茅todo `registerSale(int productId, double finalPrice)`.
> * Debe insertar en la tabla `sales` con la fecha/hora actual (`QDateTime::currentDateTime()`).
> 
> 
> 3. Debe restar stock y registrar la venta.
> 
> 
> Dame el c贸digo C++ para conectar esto a la base de datos.

### Prompt 6: Interfaz Gr谩fica Moderna (UI/QML)

Aqu铆 unimos todo con "Vibe" visual.

> **Prompt:**
> Ahora actuemos como Dise帽ador UI/UX. Vamos a crear la interfaz en QML (`src/ui`).
> **Estilo:** Windows 11, limpio, uso de `QtQuick.Controls`, fondo claro, esquinas redondeadas.
> **Estructura de Vistas:**
> 1. Una barra lateral o pesta帽as superiores para navegar: "Ventas", "Inventario", "Configuraci贸n".
> 2. **Vista Inventario:** Un `ListView` o `TableView` elegante mostrando los productos. Un bot贸n flotante (+) para agregar. Un formulario modal para editar.
> 3. **Vista Ventas:** Un buscador de productos simple. Al hacer clic en un producto, confirma la venta y guarda.
> 4. **Vista Configuraci贸n:** Un campo grande y claro para actualizar la "Tasa de Cambio (USD)".
> 
> 
> Genera el c贸digo `Main.qml` y componentes necesarios (`ProductItem.qml`, `Sidebar.qml`) integrando las clases C++ que creamos antes (`CurrencyService`, `ProductModel`, `SalesController`).

### Prompt 7: Reportes y Cierre

El toque final.

> **Prompt:**
> Finalmente, necesito la capacidad de reportes en `src/features/reporting`.
> **Tarea:**
> 1. Crea una clase simple que ejecute una query SQL para agrupar ventas por d铆a y por producto: `SELECT product_id, SUM(sale_price), date(...) FROM sales GROUP BY ...`.
> 2. Muestra estos datos en una tabla en una nueva pesta帽a "Reportes" en QML. Con posibilidad de exportar en excel, imprimir, pdf
> 
> 
> Dame el c贸digo C++ y la actualizaci贸n del QML para ver esta tabla.

---

### 驴Qu茅 sigue ahora?

驴Te gustar铆a que comience **ejecutando yo mismo el primer prompt** para darte la estructura de archivos y el CMake listo para copiar y pegar, o prefieres ir directamente a la implementaci贸n de la Base de Datos?
